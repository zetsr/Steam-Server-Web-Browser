<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Steam Server Web Browser</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Great+Vibes&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.0/dist/chartjs-plugin-zoom.min.js"></script>
  <style>
    :root{
      --bg:#07080a;
      --muted:#9aa3b2;
      --text:#d7e1ea;
      --accent:#6ee7b7;
      --accent-2:#4fd6a6;
      --glass-border: rgba(255,255,255,0.04);
      --radius:12px;
      --shadow-strong: 0 8px 30px rgba(2,6,23,0.7);
      --ease: cubic-bezier(.16,.84,.3,1);
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:"Inter",Arial,sans-serif;-webkit-font-smoothing:antialiased;background:var(--bg);color:var(--text)}
    body::before{
      content:"";
      position:fixed;
      inset:-20%;
      z-index:-2;
      background:
        radial-gradient(800px 400px at 10% 20%, rgba(110,231,183,0.06), transparent 15%),
        radial-gradient(700px 350px at 85% 80%, rgba(120,126,255,0.04), transparent 10%),
        conic-gradient(from 180deg at 50% 50%, rgba(255,255,255,0.01), rgba(0,0,0,0.02));
      filter: blur(40px) saturate(105%);
      transform: rotate(-2deg);
      animation: bgDrift 18s linear infinite alternate;
    }
    @keyframes bgDrift { 0% { transform: translateY(0) scale(1) rotate(-2deg); } 100% { transform: translateY(-8px) scale(1.02) rotate(-1deg); } }

    /* 自定义滚动条样式 */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.02);
      border-radius: 5px;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.1);
      border-radius: 5px;
      border: 2px solid rgba(0,0,0,0.2);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.15);
    }

    ::-webkit-scrollbar-corner {
      background: rgba(0,0,0,0.1);
    }

    /* Firefox 滚动条样式 */
    html {
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,0.1) rgba(255,255,255,0.02);
    }

    .app{ max-width:1200px; width: calc(100% - 56px); margin:28px auto; padding:20px; border-radius:16px; background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); box-shadow: var(--shadow-strong); position:relative; overflow:visible; border:1px solid rgba(255,255,255,0.02); backdrop-filter: blur(6px) saturate(1.05); }

    .header{ display:flex; align-items:center; gap:16px; margin-bottom:16px; position: relative; }
    .logo{ width:64px; height:64px; border-radius:10px; background: linear-gradient(135deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); display:flex; align-items:center; justify-content:center; border:1px solid var(--glass-border); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02), 0 6px 18px rgba(2,6,23,0.6); flex-shrink:0 }
    .title-wrap{ flex:1; min-width:0 }
    .title{ font-size:18px; font-weight:600; color:var(--text); margin:0; }
    .subtitle{ margin-top:4px; color:var(--muted); font-size:13px }
    .visitor-count{ 
      position: absolute; 
      right: 0; 
      top: 0; 
      padding: 6px 12px; 
      background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.008)); 
      border-radius: 8px; 
      border: 1px solid rgba(255,255,255,0.03); 
      color: var(--text); 
      font-size: 13px; 
      font-weight: 600; 
      box-shadow: 0 4px 12px rgba(2,6,23,0.4); 
    }

    /* 选项卡样式 */
    .tab-container {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .tab-btn {
      padding: 10px 20px;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.008));
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s var(--ease);
    }
    
    .tab-btn.active {
      background: linear-gradient(180deg, rgba(110,231,183,0.06), rgba(110,231,183,0.02));
      border-color: rgba(110,231,183,0.12);
      color: var(--accent);
    }
    
    .tab-btn:hover:not(.active) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(2,6,23,0.6);
    }

    .controls{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; padding:12px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.008)); border:1px solid var(--glass-border); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); margin-bottom:16px; }

    .btn{ appearance:none; border:none; outline:none; padding:10px 14px; border-radius:10px; background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.008)); color:var(--text); font-weight:600; font-size:13px; cursor:pointer; border:1px solid rgba(255,255,255,0.03); box-shadow:0 6px 18px rgba(2,6,23,0.5); transition: transform .14s var(--ease), box-shadow .14s var(--ease); display:inline-flex; align-items:center; gap:8px; min-height:40px; }
    .btn:hover{ transform: translateY(-3px); box-shadow: 0 12px 30px rgba(2,6,23,0.65); }
    .btn:active{ transform: translateY(-1px) scale(.997); }

    .refresh-btn{ background: linear-gradient(180deg, rgba(110,231,183,0.06), rgba(110,231,183,0.02)); border:1px solid rgba(110,231,183,0.12); color:var(--text); padding:10px 18px; border-radius:10px; font-weight:700; }
    .refresh-btn:disabled{ opacity:0.5; transform:none; cursor:not-allowed; box-shadow:none; }

    .search-input {
      padding: 10px 14px;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.008));
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.03);
      font-size: 13px;
      min-width: 200px;
      box-shadow: 0 6px 18px rgba(2,6,23,0.5);
      transition: transform .14s var(--ease), box-shadow .14s var(--ease);
    }
    
    .search-input:focus {
      outline: none;
      border-color: rgba(110,231,183,0.12);
      box-shadow: 0 12px 30px rgba(2,6,23,0.65);
    }

    .dropdown, .multiselect{ position:relative; display:inline-block; min-width:150px; }
    .dropdown-btn, .multiselect-btn{ width:100%; text-align:left; padding:10px 14px; border-radius:10px; background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.03); cursor:pointer; font-weight:600; font-size:13px; }
    .dropdown-btn::after, .multiselect-btn::after { content: '▾'; float:right; opacity:0.8; font-size:12px; transition: transform .18s var(--ease); }
    .dropdown.open .dropdown-btn::after, .multiselect.open .multiselect-btn::after { transform: rotate(180deg); }

    .dropdown-content, .multiselect-content{
      position:absolute; top:calc(100% + 10px); left:0;
      min-width:220px; max-width:360px;
      background: rgba(14,16,18,0.96);
      color:var(--text);
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.06);
      box-shadow: 0 18px 60px rgba(0,0,0,0.75);
      padding:8px;
      z-index:120;
      transform-origin: top center;
      opacity:0; pointer-events:none;
      transform: translateY(-6px) scale(.98);
      transition: opacity .18s var(--ease), transform .18s var(--ease);
      backdrop-filter: blur(12px) saturate(1.05);
    }
    .dropdown.open .dropdown-content, .multiselect.open .multiselect-content { opacity:1; pointer-events:auto; transform: translateY(0) scale(1); }

    .dropdown-content div, .multiselect-content label { display:flex; gap:8px; align-items:center; padding:8px 10px; border-radius:8px; cursor:pointer; color:var(--text); font-size:13px; }
    .dropdown-content div:hover, .multiselect-content label:hover { background: rgba(255,255,255,0.02); }
    .multiselect-content{ max-height:320px; overflow:auto; width:260px; }
    .multiselect-content input[type="checkbox"] { width:16px; height:16px; accent-color:var(--accent); flex-shrink:0; }
    .flag-icon{ width:28px; height:18px; border-radius:3px; object-fit:cover; flex-shrink:0; }

    .status-container{ display:flex; align-items:center; gap:12px; margin:6px 0 16px; position:relative; min-height:48px; padding:8px 12px; border-radius:12px; border:1px solid var(--glass-border); background: linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.004)); }
    .status{ color:var(--text); font-weight:600; font-size:14px; }
    .last-updated{ color:var(--muted); font-size:13px; }
    .powered-by-wrap{ margin-left:auto; display:flex; flex-direction:column; align-items:flex-end; }
    .powered-by{ font-family:'Great Vibes', cursive; color:var(--accent-2); font-size:16px; text-shadow: 0 1px 0 rgba(0,0,0,0.6); position: relative; top: -4px; }
    .powered-by a { color:var(--accent-2); text-decoration:none; }
    .powered-by a:hover { text-decoration:underline; opacity:0.95; }
    .support-link { 
      font-size: 13px; 
      color: var(--accent); 
      cursor: pointer; 
      text-decoration: none; 
      transition: color 0.2s var(--ease); 
    }
    .support-link:hover { color: var(--text); text-decoration: underline; }

    /* --- Modal Styles --- */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(8px);
      z-index: 150;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s var(--ease);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .modal.show {
      opacity: 1;
      pointer-events: auto;
    }
    .modal-content {
      position: relative;
      background: rgba(14,16,18,0.96);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 18px 60px rgba(0,0,0,0.75);
      padding: 24px;
      padding-top: 56px; /* Extra space for close button */
      max-width: 550px; /* Reduced width */
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      text-align: center;
      transform: scale(0.95);
      transition: transform 0.3s var(--ease);
    }
    .modal.show .modal-content {
      transform: scale(1);
    }
    .modal-content img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    .modal-content p {
      color: var(--text);
      font-size: 14px;
      line-height: 1.5;
      margin: 0 0 16px;
    }
    .close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      color: var(--muted);
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s var(--ease);
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      padding: 0;
    }
    .close-btn:hover {
      color: var(--text);
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.1) rotate(90deg);
    }

    /* 服务器历史数据模态框样式 */
    .history-modal .modal-content {
      max-width: 800px;
      padding: 24px;
      padding-top: 56px;
      text-align: left;
    }
    .history-header {
      margin-bottom: 20px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      padding-bottom: 15px;
      position: relative;
    }
    .history-title {
      font-size: 20px;
      margin: 0 0 8px 0;
      color: var(--accent);
      padding-right: 200px; /* 为按钮留出空间 */
    }
    .history-subtitle {
      color: var(--muted);
      margin: 0;
      font-size: 14px;
      padding-right: 200px; /* 为按钮留出空间 */
    }
    .history-chart-container {
      margin-bottom: 20px;
      position: relative;
      height: 300px;
    }
    .history-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    .history-table th,
    .history-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .history-table th {
      color: var(--muted);
      font-weight: 600;
      font-size: 13px;
    }
    .history-table td {
      color: var(--text);
      font-size: 13px;
    }
    .history-table tr:last-child td {
      border-bottom: none;
    }
    .no-data {
      text-align: center;
      color: var(--muted);
      padding: 40px 0;
      font-style: italic;
    }

    /* 全球统计数据样式 */
    .global-stats-container {
      display: none;
    }
    
    .global-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    
    .game-stat-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.003));
      border: 1px solid rgba(255,255,255,0.02);
      border-radius: 12px;
      padding: 20px;
      transition: all 0.3s var(--ease);
    }
    
    .game-stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 30px rgba(2,6,23,0.6);
      border-color: rgba(110,231,183,0.1);
    }
    
    .game-icon {
      width: 64px;
      height: 64px;
      border-radius: 8px;
      object-fit: cover;
      margin-bottom: 12px;
    }
    
    .game-name {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text);
    }
    
    .game-appid {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 12px;
    }
    
    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 13px;
    }
    
    .stat-label {
      color: var(--muted);
    }
    
    .stat-value {
      color: var(--text);
      font-weight: 600;
    }
    
    .global-chart-container {
      margin-top: 30px;
      position: relative;
      height: 400px;
    }
    
    .time-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      justify-content: center;
    }
    
    .time-btn {
      padding: 6px 12px;
      border-radius: 6px;
      background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.008));
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s var(--ease);
    }
    
    .time-btn.active {
      background: linear-gradient(180deg, rgba(110,231,183,0.06), rgba(110,231,183,0.02));
      border-color: rgba(110,231,183,0.12);
      color: var(--accent);
    }
    
    .chart-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 15px;
      justify-content: center;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    .table-container{ 
      overflow-x: hidden; 
      overflow-y: hidden; /* 修复：始终隐藏垂直滚动条 */
      border-radius:12px; 
      padding:6px; 
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.003)); 
      border:1px solid rgba(255,255,255,0.02); 
      transition: overflow-y 0.3s ease; /* 平滑过渡效果 */
      position: relative;
      min-height: 400px; /* 确保有足够高度显示加载动画 */
    }
    
    /* 加载动画样式 */
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(7, 8, 10, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      border-radius: 12px;
      backdrop-filter: blur(4px);
    }
    
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top: 3px solid var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .loading-text {
      color: var(--text);
      margin-top: 16px;
      font-size: 14px;
      text-align: center;
    }
    
    /* 添加一个类用于在渲染期间锁定高度 */
    .table-container.lock-height {
      height: var(--table-container-height);
      overflow-y: hidden !important;
    }

    table{ width:100%; border-collapse:separate; border-spacing:0; background:transparent; table-layout:auto; }

    thead th{
      position: sticky; top:0;
      background: linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.006));
      color:var(--muted); font-weight:700; font-size:13px;
      padding:12px 10px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.03);
      backdrop-filter: blur(4px); z-index:8;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      writing-mode: horizontal-tb;
    }

    /* --- Table Row Animation Styles --- */
    tbody tr{
      background: linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.002));
      border-bottom:1px solid rgba(255,255,255,0.02); color:var(--text);
      /* Use a single transition for transform for FLIP to work smoothly */
      transition: background .22s var(--ease), box-shadow .22s var(--ease), opacity 0.3s var(--ease);
      will-change: transform, opacity; /* Performance hint for the browser */
    }
    tbody tr.moving {
        transition: transform 0.5s var(--ease); /* This class will be added during FLIP animation */
    }
    tbody tr:hover{ 
        /* Avoid transform on hover to not interfere with FLIP */
        box-shadow: 0 14px 30px rgba(2,6,23,0.55); 
        background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); 
        color:#fff; 
    }
    tbody tr.new-row { 
        animation: rowPopIn 0.4s var(--ease) forwards;
    }
    @keyframes rowPopIn {
        0% { transform: translateY(10px) scale(0.98); opacity: 0; }
        100% { transform: translateY(0) scale(1); opacity: 1; }
    }
    tbody tr.removing {
      opacity: 0;
      transform: translateX(-20px) scale(0.98);
      transition: transform 0.3s var(--ease), opacity 0.3s var(--ease);
    }
    /* --- End Animation Styles --- */

    td{ padding:10px; font-size:13px; vertical-align:middle; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; writing-mode: horizontal-tb; }
    td.name { cursor: pointer; }
    td.latency { transition: color .3s var(--ease); }
    td.latency.updated { animation: color-flash 0.6s var(--ease); }
    @keyframes color-flash {
        0%, 100% { color: var(--text); }
        50% { color: var(--accent); }
    }

    th.game, td.game { white-space:normal; overflow-wrap:anywhere; word-break:break-word; min-width:140px; max-width:200px; width:12%; }
    th.name, td.name { white-space:normal; overflow-wrap:anywhere; word-break:break-word; min-width:160px; max-width:220px; width:30%; }
    th.ip, td.ip { white-space:normal; overflow-wrap:anywhere; word-break:break-word; min-width:120px; max-width:160px; width:19%; }
    th.isp, td.isp { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; min-width:110px; max-width:150px; width:8%; }
    th.os, td.os { white-space:normal; overflow-wrap:anywhere; word-break:break-word; min-width:80px; max-width:100px; width:8%; }
    th.players, td.players { white-space:normal; word-break:normal; min-width:80px; max-width:100px; width:8%; text-align:center; }
    th.map, td.map { white-space:nowrap; min-width:72px; max-width:100px; width:7%; text-align:center; }
    th.version, td.version { white-space:normal; overflow-wrap:anywhere; min-width:90px; max-width:120px; width:8%; text-align:center; }
    th.latency, td.latency { white-space:normal; min-width:70px; max-width:90px; width:6%; text-align:center; }
    th.country, td.country { width:56px; max-width:60px; text-align:center; white-space:nowrap; min-width:56px; }

    tr.zero-players td{ opacity:0.78; color:var(--muted); filter:grayscale(.2); }

    .ip-link{ color:var(--text); text-decoration:none; font-weight:600; }
    .ip-link:hover{ text-decoration:underline; color:var(--accent); }

    .badge{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; font-size:12px; font-weight:700; background: rgba(255,255,255,0.01); border:1px solid rgba(255,255,255,0.02); }
    .badge.latency{ color:var(--muted); min-width:68px; justify-content:center; }
    .badge.players{ color:var(--text); background: linear-gradient(90deg, rgba(110,231,183,0.06), rgba(110,231,183,0.02)); border:1px solid rgba(110,231,183,0.08); }

    .footer-links{ margin-top:22px; color:var(--muted); text-align:center; font-size:13px; display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }
    .footer-links a{ color:var(--muted); text-decoration:none; border-bottom:1px dashed rgba(255,255,255,0.02); padding-bottom:2px; }
    .footer-links a:hover{ color:var(--text); border-bottom-color: rgba(255,255,255,0.04); }

    /* 分页样式 */
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    
    .page-btn {
      padding: 8px 12px;
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.008));
      color: var(--text);
      border: 1px solid rgba(255,255,255,0.03);
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s var(--ease);
      min-width: 40px;
      text-align: center;
    }
    
    .page-btn:hover:not(.disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(2,6,23,0.6);
      border-color: rgba(110,231,183,0.12);
    }
    
    .page-btn.active {
      background: linear-gradient(180deg, rgba(110,231,183,0.06), rgba(110,231,183,0.02));
      border-color: rgba(110,231,183,0.12);
      color: var(--accent);
    }
    
    .page-btn.disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none !important;
    }

    .tooltip {
      position: absolute;
      background: rgba(14,16,18,0.96);
      color: var(--text);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 8px 20px rgba(0,0,0,0.5);
      padding: 8px 12px;
      font-size: 13px;
      z-index: 130;
      max-width: 300px;
      white-space: normal;
      word-break: break-word;
      pointer-events: none;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity .2s var(--ease), transform .2s var(--ease);
    }
    .tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* 新增：标签行样式 */
    tr.tag-row {
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.003));
      border-bottom: 1px solid rgba(255,255,255,0.02);
    }

    tr.tag-row td {
      padding: 12px 10px;
      border-top: none;
      vertical-align: middle;
    }

    .tag-container {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    /* 重新设计的标签样式 - 半透明填充，不透明边框 */
    .tag {
      padding: 6px 12px;
      border-radius: 8px; /* 改为较小的圆角，更现代 */
      font-size: 11px; /* 稍微减小字体大小 */
      font-weight: 600; /* 降低字重，不那么突出 */
      color: rgba(255, 255, 255, 0.9); /* 使用半透明白色文字 */
      border: 1px solid; /* 不透明边框 */
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15); /* 更柔和的阴影 */
      transition: all 0.2s var(--ease);
      background: rgba(255, 255, 255, 0.08); /* 半透明填充 */
      backdrop-filter: blur(5px); /* 玻璃态模糊效果 */
      position: relative;
      overflow: hidden;
    }

    /* 添加微妙的发光效果 */
    .tag::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.03), transparent);
      opacity: 0;
      transition: opacity 0.2s var(--ease);
      z-index: -1;
    }

    .tag:hover {
      transform: translateY(-1px); /* 更微妙的悬停效果 */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      background: rgba(255, 255, 255, 0.12); /* 悬停时稍微增加透明度 */
    }

    .tag:hover::before {
      opacity: 1;
    }

    /* 调整表格行高以适应标签行 */
    tbody tr {
      height: 48px; /* 原高度 */
    }

    tbody tr.tag-row {
      height: 60px; /* 标签行高度 */
    }

    /* 玩家列表模态框样式 */
    .player-list-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .player-list-table th,
    .player-list-table td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }

    .player-list-table th {
      color: var(--muted);
      font-weight: 600;
      font-size: 13px;
      background: linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.006));
    }

    .player-list-table td {
      color: var(--text);
      font-size: 13px;
    }

    .player-list-table tr:last-child td {
      border-bottom: none;
    }

    .player-list-btn {
      position: absolute;
      top: 10px;
      right: 60px;
      padding: 10px 20px;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(110,231,183,0.06), rgba(110,231,183,0.02));
      border: 1px solid rgba(110,231,183,0.12);
      color: var(--text);
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s var(--ease);
    }

    .player-list-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(2,6,23,0.6);
      background: linear-gradient(180deg, rgba(110,231,183,0.08), rgba(110,231,183,0.04));
    }

    @media (max-width: 680px) {
      .app { width: calc(100% - 24px); padding:12px; margin:12px auto; max-width:none; }
      .controls { flex-direction:column; align-items:stretch; gap:10px; }
      .dropdown, .multiselect { width:100%; }
      .search-input {
        width: 100%;
        min-width: auto;
      }
      .visitor-count { 
        position: static; 
        margin-left: auto; 
        font-size: 12px; 
        padding: 4px 8px; 
      }
      .powered-by-wrap { align-items: flex-end; }
      table thead th:nth-child(4),
      table tbody td:nth-child(4),
      table thead th:nth-child(5),
      table tbody td:nth-child(5),
      table thead th:nth-child(6),
      table tbody td:nth-child(6),
      table thead th:nth-child(8),
      table tbody td:nth-child(8),
      table thead th:nth-child(9),
      table tbody td:nth-child(9),
      table thead th:nth-child(10),
      table tbody td:nth-child(10) {
        display:none;
      }
      table { table-layout: fixed; width: 100%; }
      table thead th:nth-child(1), table tbody td:nth-child(1) { width: 15%; min-width: 50px; }
      table thead th:nth-child(2), table tbody td:nth-child(2) { width: 35%; min-width: 100px; }
      table thead th:nth-child(3), table tbody td:nth-child(3) { width: 35%; min-width: 90px; }
      table thead th:nth-child(7), table tbody td:nth-child(7) { width: 15%; min-width: 60px; }
      th.country, th.players {
        white-space: nowrap;
        overflow: visible;
        text-overflow: unset;
        font-size: 12px;
        padding: 8px 4px;
        text-align: center;
      }
      th.game, td.game,
      th.name, td.name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        writing-mode: horizontal-tb;
        font-size: 12px;
        padding: 8px 4px;
      }
      td.country {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 8px 4px;
      }
      td.country img.flag-icon {
        width: 24px;
        height: 16px;
        margin: 0 auto;
      }
      td.country:not(:has(img)) {
        font-size: 12px;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      td.players {
        text-align: center;
        font-size: 12px;
        padding: 8px 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      thead th:nth-child(1), tbody td:nth-child(1),
      thead th:nth-child(2), tbody td:nth-child(2),
      thead th:nth-child(3), tbody td:nth-child(3),
      thead th:nth-child(7), tbody td:nth-child(7) {
        display: table-cell;
        writing-mode: horizontal-tb;
      }
      .logo { display: none; }
      .title { font-size: 16px; }
      .table-container { overflow: visible; }
      .tooltip {
        max-width: 90%;
        font-size: 12px;
        padding: 6px 10px;
      }
      .history-modal .modal-content {
        padding: 16px;
        padding-top: 48px;
      }
      .history-title {
        font-size: 18px;
      }
      .history-chart-container {
        height: 200px;
      }
      .pagination {
        gap: 4px;
      }
      .page-btn {
        padding: 6px 8px;
        font-size: 12px;
        min-width: 32px;
      }
      .global-stats-grid {
        grid-template-columns: 1fr;
      }
      .time-controls {
        flex-wrap: wrap;
      }
      .player-list-btn {
        position: static;
        margin-top: 10px;
        width: 100%;
      }
      .history-title, .history-subtitle {
        padding-right: 0;
      }
    }

    .multiselect-content::-webkit-scrollbar, .dropdown-content::-webkit-scrollbar { height:10px; width:10px; }
    .multiselect-content::-webkit-scrollbar-thumb, .dropdown-content::-webkit-scrollbar-thumb {
      border-radius:6px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:2px solid rgba(0,0,0,0.12);
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="header" role="banner">
      <div class="logo" aria-hidden="true">
        <svg width="44" height="44" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="20" height="20" rx="5" fill="rgba(255,255,255,0.02)"/><path d="M7 12h10M7 8h10M7 16h6" stroke="rgba(110,231,183,0.9)" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </div>
      <div class="title-wrap">
        <h1 class="title">pvp.ink</h1>
        <div class="subtitle">最好的龙游服务器网站</div>
      </div>
      <div class="visitor-count" id="visitorCount">0 位访客</div>
    </header>

    <div class="tab-container">
      <button class="tab-btn active" id="homeTab" onclick="switchTab('home')">主页</button>
      <button class="tab-btn" id="globalStatsTab" onclick="switchTab('globalStats')">全球统计数据</button>
    </div>

    <div id="homeContent">
      <div class="controls" role="region" aria-label="Controls">
        <input type="text" class="search-input" id="serverSearch" placeholder="搜索服务器名称" title="输入服务器名称进行筛选">

        <div class="multiselect" id="regionFilter">
          <button class="multiselect-btn" onclick="toggleRegionMultiselect()">选择地区</button>
          <div class="multiselect-content" id="regionFilterOptions" aria-hidden="true"></div>
        </div>

        <div class="multiselect" id="gameFilter">
          <button class="multiselect-btn" onclick="toggleGameMultiselect()">选择游戏</button>
          <div class="multiselect-content" id="gameFilterOptions" aria-hidden="true"></div>
        </div>

        <div class="dropdown" id="sortDropdown">
          <button class="dropdown-btn" onclick="toggleDropdown()">按人数排序</button>
          <div class="dropdown-content" id="sortOptions" role="menu" aria-hidden="true">
            <div onclick="selectSort('players')" role="menuitem">按人数排序</div>
            <div onclick="selectSort('name')" role="menuitem">按名称排序</div>
            <div onclick="selectSort('latency')" role="menuitem">按延迟排序</div>
          </div>
        </div>
      </div>

      <div class="status-container" role="status" aria-live="polite">
        <div class="status" id="status">正在初始化...</div>
        <div class="last-updated hidden">最后更新于 <span id="updateTime">0</span> 秒之前</div>
        <div class="powered-by-wrap">
          <div class="powered-by"><a href="https://github.com/zetsr/Steam-Server-Web-Browser" target="_blank" rel="noopener noreferrer">Powered by zetsr</a></div>
          <a class="support-link" onclick="showSupportModal()">支持一下♥</a>
        </div>
      </div>

      <div class="table-container" aria-label="Server Table">
        <div class="loading-overlay" id="loadingOverlay">
          <div>
            <div class="loading-spinner"></div>
            <div class="loading-text">正在加载服务器列表...</div>
          </div>
        </div>
        
        <table id="serverTable" role="table" aria-describedby="status">
          <thead>
            <tr>
              <th class="country">国家</th>
              <th class="game">游戏名称</th>
              <th class="name">服务器名称</th>
              <th class="ip">服务器IP</th>
              <th class="isp">服务商</th>
              <th class="os">操作系统</th>
              <th class="players">在线玩家</th>
              <th class="map">地图</th>
              <th class="version">版本</th>
              <th class="latency">延迟 (ms)</th>
            </tr>
          </thead>
          <tbody id="serverList"></tbody>
        </table>
      </div>

      <div class="pagination" id="paginationContainer"></div>
    </div>

    <div class="global-stats-container" id="globalStatsContent">
      <div class="global-stats-grid" id="globalStatsGrid">
      </div>
      
      <div class="global-chart-container">
        <div class="time-controls">
          <button class="time-btn active" onclick="changeGlobalTimeRange('day')">日</button>
          <button class="time-btn" onclick="changeGlobalTimeRange('week')">周</button>
          <button class="time-btn" onclick="changeGlobalTimeRange('month')">月</button>
          <button class="time-btn" onclick="changeGlobalTimeRange('year')">年</button>
        </div>
        <canvas id="globalStatsChart"></canvas>
        <div class="chart-legend" id="globalChartLegend"></div>
      </div>
    </div>

    <!--这里有个BUG没修复，坐标有问题，会跟全球统计数据的游戏名称重叠-->

    <!--<div class="footer-links">
      <div><a href="https://ipinfo.io" target="_blank" rel="noopener noreferrer">IP Data by ipinfo.io</a></div>
      <div><a href="https://developer.valvesoftware.com/wiki/Master_Server_Query_Protocol" target="_blank" rel="noopener noreferrer">Valve Master Server</a></div>
      <div><a href="https://developer.valvesoftware.com/wiki/Server_queries" target="_blank" rel="noopener noreferrer">A2S Server Queries</a></div>
    </div>-->
  </div>
  <div class="modal" id="supportModal">
    <div class="modal-content">
      <button class="close-btn" onclick="hideSupportModal()">×</button>
      <img src="pay.jpg" alt="赞助二维码">
      <p>您的赞助将帮助我们维持服务器的运行和持续改进服务。扫描上方二维码即可赞助我们，感谢您的支持！</p>
    </div>
  </div>

  <div class="modal history-modal" id="historyModal">
    <div class="modal-content">
      <button class="close-btn" onclick="hideHistoryModal()">×</button>
      <div class="history-header">
        <h2 class="history-title" id="historyServerName">服务器名称</h2>
        <p class="history-subtitle" id="historyServerInfo">IP:端口 | 服务商: -</p>
        <button class="player-list-btn" id="playerListBtn">玩家列表</button>
      </div>
      
      <div class="time-controls">
        <button class="time-btn active" onclick="changeHistoryTimeRange('day')">日</button>
        <button class="time-btn" onclick="changeHistoryTimeRange('week')">周</button>
        <button class="time-btn" onclick="changeHistoryTimeRange('month')">月</button>
        <button class="time-btn" onclick="changeHistoryTimeRange('year')">年</button>
      </div>
      
      <div class="history-chart-container">
        <canvas id="historyChart"></canvas>
      </div>
      <div id="historyTableContainer">
        <table class="history-table">
          <thead>
            <tr>
              <th>日期</th>
              <th>最大在线人数</th>
            </tr>
          </thead>
          <tbody id="historyTableBody">
          </tbody>
        </table>
      </div>
      <div class="no-data" id="historyNoData" style="display: none;">
        暂无历史数据
      </div>
    </div>
  </div>

  <div class="modal" id="playerListModal">
    <div class="modal-content">
      <button class="close-btn" onclick="hidePlayerListModal()">×</button>
      <div class="history-header">
        <h2 class="history-title" id="playerListServerName">服务器名称</h2>
        <p class="history-subtitle" id="playerListServerInfo">IP:端口 | 服务商: -</p>
      </div>
      <div id="playerListContainer">
        <table class="player-list-table">
          <thead>
            <tr>
              <th>玩家名称</th>
              <th>在线时间</th>
              <th>分数</th>
            </tr>
          </thead>
          <tbody id="playerListTableBody">
          </tbody>
        </table>
      </div>
      <div class="no-data" id="playerListNoData" style="display: none;">
        暂无玩家在线
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
    Chart.register(ChartZoom);

    const tbody = document.getElementById('serverList');
    const statusDiv = document.getElementById('status');
    const gameFilter = document.getElementById('gameFilter');
    const gameFilterBtn = gameFilter.querySelector('.multiselect-btn');
    const gameFilterOptions = document.getElementById('gameFilterOptions');
    const regionFilter = document.getElementById('regionFilter');
    const regionFilterBtn = regionFilter.querySelector('.multiselect-btn');
    const regionFilterOptions = document.getElementById('regionFilterOptions');
    const sortDropdown = document.getElementById('sortDropdown');
    const sortBtn = sortDropdown.querySelector('.dropdown-btn');
    const updateTimeSpan = document.getElementById('updateTime');
    const lastUpdatedDiv = document.querySelector('.last-updated');
    const visitorCountDiv = document.getElementById('visitorCount');
    const tableContainer = document.querySelector('.table-container');
    const searchInput = document.getElementById('serverSearch');
    const paginationContainer = document.getElementById('paginationContainer');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const homeContent = document.getElementById('homeContent');
    const globalStatsContent = document.getElementById('globalStatsContent');
    const globalStatsGrid = document.getElementById('globalStatsGrid');
    const homeTab = document.getElementById('homeTab');
    const globalStatsTab = document.getElementById('globalStatsTab');

    const historyModal = document.getElementById('historyModal');
    const historyServerName = document.getElementById('historyServerName');
    const historyServerInfo = document.getElementById('historyServerInfo');
    const historyChart = document.getElementById('historyChart');
    const historyTableBody = document.getElementById('historyTableBody');
    const historyNoData = document.getElementById('historyNoData');
    const historyTableContainer = document.getElementById('historyTableContainer');
    const playerListBtn = document.getElementById('playerListBtn');

    const globalStatsChart = document.getElementById('globalStatsChart');
    const globalChartLegend = document.getElementById('globalChartLegend');

    const playerListModal = document.getElementById('playerListModal');
    const playerListServerName = document.getElementById('playerListServerName');
    const playerListServerInfo = document.getElementById('playerListServerInfo');
    const playerListTableBody = document.getElementById('playerListTableBody');
    const playerListNoData = document.getElementById('playerListNoData');

    let serverData = new Map();
    let uniqueGames = new Set();
    let uniqueRegions = new Set();
    let currentSort = 'players';
    let urlParams = parseURLParams();
    let initialSelectedGames = urlParams.games;
    let initialSelectedRegions = urlParams.regions;
    let loadingInterval = null;
    let lastUpdateTime = null;
    let updateTimerInterval = null;
    let currentTooltip = null;
    let lastRenderedKey = null;
    let latencyUpdateQueue = new Map();
    let isRendering = false; 
    let scrollHideTimer = null;

    let currentPage = urlParams.page || 1;
    let itemsPerPage = 20;
    let totalPages = 1;
    let searchFilter = urlParams.filter || '';

    let isLoading = true;
    let loadingStartTime = null;
    let minLoadingTime = 1000;

    let currentTab = 'home';

    let historyChartInstance = null;
    let globalStatsChartInstance = null;
    let currentHistoryTimeRange = 'day';
    let currentGlobalTimeRange = 'day';
    let currentServerHistoryData = null;

    let globalStatsData = null;

    let tagColors = new Map();

    let ws = null;
    let reconnectDelay = 5000;
    const maxReconnectDelay = 60000;
    let reconnectTimeoutId = null;
    let reconnectCountdownIntervalId = null;

    // 标签缓存机制
    let tagCache = new Map(); // key -> { tags: [], disappearCount: {} }

    function getTagColor(tag) {
      if (!tagColors.has(tag)) {
        let hash = 0;
        for (let i = 0; i < tag.length; i++) {
          hash = tag.charCodeAt(i) + ((hash << 5) - hash);
        }
        const hue = hash % 360;
        const saturation = 40 + (hash % 20); // 降低饱和度
        const lightness = 35 + (hash % 15); // 降低亮度
        tagColors.set(tag, `hsl(${hue}, ${saturation}%, ${lightness}%)`);
      }
      return tagColors.get(tag);
    }

    // 处理标签缓存的函数
    function processTagsWithCache(key, newTags) {
      // 获取缓存
      let cache = tagCache.get(key);
      
      // 如果没有缓存，初始化
      if (!cache) {
        cache = {
          tags: [...(newTags || [])],
          disappearCount: {}
        };
        tagCache.set(key, cache);
        return cache.tags;
      }
      
      // 如果新标签无效，直接返回缓存的标签
      if (!newTags || !Array.isArray(newTags)) {
        return cache.tags;
      }
      
      const currentTags = new Set(newTags);
      const cachedTags = new Set(cache.tags);
      
      // 更新消失计数
      // 对于缓存中的每个标签，如果不在新标签中，增加消失计数
      cache.tags.forEach(tag => {
        if (!currentTags.has(tag)) {
          cache.disappearCount[tag] = (cache.disappearCount[tag] || 0) + 1;
        } else {
          // 如果标签重新出现，重置消失计数
          cache.disappearCount[tag] = 0;
        }
      });
      
      // 添加新标签
      newTags.forEach(tag => {
        if (!cachedTags.has(tag)) {
          cache.tags.push(tag);
          cache.disappearCount[tag] = 0; // 新标签的消失计数为0
        }
      });
      
      // 移除连续消失60次的标签
      cache.tags = cache.tags.filter(tag => {
        if (cache.disappearCount[tag] >= 60) {
          delete cache.disappearCount[tag];
          return false;
        }
        return true;
      });
      
      return cache.tags;
    }

    function parseURLParams() {
      const params = new URLSearchParams(window.location.search);
      const games = params.get('games')
        ? params.get('games').split(',').map(decodeURIComponent).filter(g => g && /^[a-zA-Z0-9\s\-_.,&]+$/.test(g))
        : [];
      const regions = params.get('regions')
        ? params.get('regions').split(',').map(decodeURIComponent).filter(r => r && /^[A-Z]{2}$/.test(r))
        : [];
      const sort = params.get('sort') || 'players';
      const filter = params.get('filter') || '';
      const page = parseInt(params.get('page')) || 1;
      return { games, regions, sort, filter, page };
    }

    function updateURL() {
      const selectedGames = getSelectedGames();
      const selectedRegions = getSelectedRegions();
      const params = new URLSearchParams();
      if (selectedGames.length > 0) params.set('games', selectedGames.map(encodeURIComponent).join(','));
      if (selectedRegions.length > 0) params.set('regions', selectedRegions.join(','));
      params.set('sort', currentSort);
      if (searchFilter) params.set('filter', searchFilter);
      if (currentPage > 1) params.set('page', currentPage);
      window.history.replaceState({}, document.title, `${window.location.pathname}?${params.toString()}`);
      urlParams = parseURLParams();
    }

    function switchTab(tabName) {
      currentTab = tabName;

      homeTab.classList.toggle('active', tabName === 'home');
      globalStatsTab.classList.toggle('active', tabName === 'globalStats');

      homeContent.style.display = tabName === 'home' ? 'block' : 'none';
      globalStatsContent.style.display = tabName === 'globalStats' ? 'block' : 'none';
      
      if (tabName === 'globalStats') {
        loadGlobalStats();
      }
    }

    function loadGlobalStats() {
      if (!globalStatsData) {
        showLoading();
        axios.get('/api/global-stats')
          .then(response => {
            globalStatsData = response.data;
            renderGlobalStats();
            hideLoading();
          })
          .catch(error => {
            console.error('获取全球统计数据失败:', error);
            hideLoading();
          });
      } else {
        renderGlobalStats();
      }
    }

    function renderGlobalStats() {
      if (!globalStatsData) return;

      renderGameStatsCards();

      renderGlobalStatsChart();
    }

    function renderGameStatsCards() {
      globalStatsGrid.innerHTML = '';
      
      Object.keys(globalStatsData.games).forEach(appId => {
        const gameData = globalStatsData.games[appId];
        const card = document.createElement('div');
        card.className = 'game-stat-card';
        
        card.innerHTML = `
          <img src="https://cdn.akamai.steamstatic.com/steam/apps/${appId}/capsule_184x69.jpg" 
               alt="${gameData.name}" class="game-icon"
               onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiByeD0iOCIgZmlsbD0icmdiYSgyNTUsIDI1NSwgMjU1LCAwLjAyKSIvPgo8dGV4dCB4PSIzMiIgeT0iMzUiIGZvbnQtZmFtaWx5PSJJbnRlciwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMiIgZmlsbD0icmdiYSgyMTUsIDIyNSwgMjM0LCAwLjYpIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIj5HYW1lPC90ZXh0Pgo8L3N2Zz4K'">
          <div class="game-name">${gameData.name}</div>
          <div class="game-appid">${appId}</div>
          <div class="stat-row">
            <span class="stat-label">总服务器数量</span>
            <span class="stat-value">${gameData.totalServers || 0}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">历史在线记录</span>
            <span class="stat-value">${gameData.maxPlayers || 0}</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">当前在线玩家</span>
            <span class="stat-value">${gameData.currentPlayers || 0}</span>
          </div>
        `;
        
        globalStatsGrid.appendChild(card);
      });
    }

    function renderGlobalStatsChart() {
      const ctx = globalStatsChart.getContext('2d');

      if (globalStatsChartInstance) {
        globalStatsChartInstance.destroy();
      }

      const aggregatedData = aggregateGlobalDataByTimeRange(globalStatsData.history, currentGlobalTimeRange);
      const labels = Object.keys(aggregatedData).sort();
      const datasets = [];

      const colors = [
        'rgba(110, 231, 183, 0.8)',
        'rgba(120, 126, 255, 0.8)',
        'rgba(255, 152, 0, 0.8)',
        'rgba(156, 39, 176, 0.8)',
        'rgba(33, 150, 243, 0.8)',
        'rgba(244, 67, 54, 0.8)',
        'rgba(76, 175, 80, 0.8)'
      ];
      
      let colorIndex = 0;
      Object.keys(globalStatsData.games).forEach(appId => {
        const gameData = globalStatsData.games[appId];
        const data = labels.map(label => aggregatedData[label]?.[appId] || 0);
        
        datasets.push({
          label: gameData.name,
          data: data,
          borderColor: colors[colorIndex % colors.length],
          backgroundColor: colors[colorIndex % colors.length].replace('0.8', '0.1'),
          tension: 0.3,
          fill: true,
          pointBackgroundColor: colors[colorIndex % colors.length],
          pointBorderColor: '#fff',
          pointBorderWidth: 2,
          pointRadius: 3,
          pointHoverRadius: 5
        });
        
        colorIndex++;
      });

      renderGlobalChartLegend(datasets);
      
      globalStatsChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels.map(label => formatDateByTimeRange(label, currentGlobalTimeRange)),
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(14, 16, 18, 0.9)',
              titleColor: 'rgba(215, 225, 234, 0.9)',
              bodyColor: 'rgba(215, 225, 234, 0.8)',
              borderColor: 'rgba(255, 255, 255, 0.1)',
              borderWidth: 1
            },
            zoom: {
              zoom: {
                wheel: {
                  enabled: true,
                },
                pinch: {
                  enabled: true
                },
                mode: 'x',
              },
              pan: {
                enabled: true,
                mode: 'x',
              }
            }
          },
          scales: {
            x: {
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              },
              ticks: {
                color: 'rgba(215, 225, 234, 0.7)'
              }
            },
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              },
              ticks: {
                color: 'rgba(215, 225, 234, 0.7)'
              }
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          }
        }
      });
    }

    function renderGlobalChartLegend(datasets) {
      globalChartLegend.innerHTML = '';
      
      datasets.forEach(dataset => {
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        legendItem.innerHTML = `
          <div class="legend-color" style="background-color: ${dataset.borderColor}"></div>
          <span>${dataset.label}</span>
        `;
        globalChartLegend.appendChild(legendItem);
      });
    }

    function aggregateGlobalDataByTimeRange(historyData, timeRange) {
      const aggregated = {};
      
      Object.keys(historyData).forEach(date => {
        const timeKey = getTimeKey(date, timeRange);
        
        if (!aggregated[timeKey]) {
          aggregated[timeKey] = {};
        }
        
        Object.keys(historyData[date]).forEach(appId => {
          if (!aggregated[timeKey][appId] || historyData[date][appId] > aggregated[timeKey][appId]) {
            aggregated[timeKey][appId] = historyData[date][appId];
          }
        });
      });
      
      return aggregated;
    }

    function getTimeKey(dateString, timeRange) {
      const date = new Date(dateString);
      
      switch (timeRange) {
        case 'week':
          const day = date.getDay();
          const diff = date.getDate() - day + (day === 0 ? -6 : 1);
          const weekStart = new Date(date.setDate(diff));
          return weekStart.toISOString().split('T')[0];
        case 'month':
          return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
        case 'year':
          return date.getFullYear().toString();
        default:
          return dateString;
      }
    }

    function formatDateByTimeRange(dateString, timeRange) {
      const date = new Date(dateString);
      
      switch (timeRange) {
        case 'week':
          const weekStart = new Date(date);
          const weekEnd = new Date(weekStart);
          weekEnd.setDate(weekStart.getDate() + 6);
          return `${formatDate(weekStart.toISOString().split('T')[0])} - ${formatDate(weekEnd.toISOString().split('T')[0])}`;
        case 'month':
          return date.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long' });
        case 'year':
          return date.getFullYear().toString();
        default:
          return formatDate(dateString);
      }
    }

    function changeGlobalTimeRange(range) {
      currentGlobalTimeRange = range;

      document.querySelectorAll('.global-chart-container .time-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent === getTimeRangeText(range));
      });

      if (globalStatsData) {
        renderGlobalStatsChart();
      }
    }

    function changeHistoryTimeRange(range) {
      currentHistoryTimeRange = range;

      document.querySelectorAll('.history-modal .time-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent === getTimeRangeText(range));
      });

      if (currentServerHistoryData) {
        renderHistoryChart(currentServerHistoryData);
      }
    }

    function getTimeRangeText(range) {
      switch (range) {
        case 'week': return '周';
        case 'month': return '月';
        case 'year': return '年';
        default: return '日';
      }
    }

    function renderHistoryChart(historyData) {
      const ctx = historyChart.getContext('2d');

      if (historyChartInstance) {
        historyChartInstance.destroy();
      }

      const aggregatedData = aggregateHistoryDataByTimeRange(historyData.history, currentHistoryTimeRange);
      const labels = Object.keys(aggregatedData).sort();
      const playerCounts = labels.map(label => aggregatedData[label]);
      
      historyChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels.map(label => formatDateByTimeRange(label, currentHistoryTimeRange)),
          datasets: [{
            label: '最大在线人数',
            data: playerCounts,
            borderColor: 'rgba(110, 231, 183, 0.8)',
            backgroundColor: 'rgba(110, 231, 183, 0.1)',
            tension: 0.3,
            fill: true,
            pointBackgroundColor: 'rgba(110, 231, 183, 1)',
            pointBorderColor: '#fff',
            pointBorderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              labels: {
                color: 'rgba(215, 225, 234, 0.8)'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(14, 16, 18, 0.9)',
              titleColor: 'rgba(215, 225, 234, 0.9)',
              bodyColor: 'rgba(215, 225, 234, 0.8)',
              borderColor: 'rgba(255, 255, 255, 0.1)',
              borderWidth: 1,
              displayColors: false
            },
            zoom: {
              zoom: {
                wheel: {
                  enabled: true,
                },
                pinch: {
                  enabled: true
                },
                mode: 'x',
              },
              pan: {
                enabled: true,
                mode: 'x',
              }
            }
          },
          scales: {
            x: {
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              },
              ticks: {
                color: 'rgba(215, 225, 234, 0.7)'
              }
            },
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              },
              ticks: {
                color: 'rgba(215, 225, 234, 0.7)'
              }
            }
          },
          interaction: {
            mode: 'nearest',
            axis: 'x',
            intersect: false
          }
        }
      });
    }

    function aggregateHistoryDataByTimeRange(historyData, timeRange) {
      const aggregated = {};
      
      Object.keys(historyData).forEach(date => {
        const timeKey = getTimeKey(date, timeRange);
        
        if (!aggregated[timeKey] || historyData[date] > aggregated[timeKey]) {
          aggregated[timeKey] = historyData[date];
        }
      });
      
      return aggregated;
    }

    function showHistoryModal(server) {
      const key = `${server.ip}:${server.port}`;
      historyServerName.textContent = server.name || '未知服务器';
      historyServerInfo.textContent = `${server.ip}:${server.port} | ${server.isp || '-'}`;

      historyTableBody.innerHTML = '<tr><td colspan="2" style="text-align: center;">加载中...</td></tr>';
      historyNoData.style.display = 'none';
      historyTableContainer.style.display = 'table';

      currentHistoryTimeRange = 'day';
      document.querySelectorAll('.history-modal .time-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent === '日');
      });

      if (historyChartInstance) {
        historyChartInstance.destroy();
        historyChartInstance = null;
      }

      historyModal.classList.add('show');

      playerListBtn.onclick = () => {
        hideHistoryModal();
        showPlayerListModal(server);
      };

      axios.get(`/api/server-history/${encodeURIComponent(key)}`)
        .then(response => {
          const historyData = response.data;
          currentServerHistoryData = historyData;
          renderHistoryData(historyData);
        })
        .catch(error => {
          console.error('获取服务器历史数据失败:', error);
          historyTableBody.innerHTML = '<tr><td colspan="2" style="text-align: center; color: var(--muted);">获取历史数据失败</td></tr>';
          historyNoData.style.display = 'block';
          historyTableContainer.style.display = 'none';
        });
    }

    function renderHistoryData(historyData) {
      if (!historyData.history || Object.keys(historyData.history).length === 0) {
        historyNoData.style.display = 'block';
        historyTableContainer.style.display = 'none';
        return;
      }
      
      historyNoData.style.display = 'none';
      historyTableContainer.style.display = 'table';

      historyTableBody.innerHTML = '';
      const dates = Object.keys(historyData.history).sort();
      dates.forEach(date => {
        const row = document.createElement('tr');
        const dateCell = document.createElement('td');
        const countCell = document.createElement('td');
        
        dateCell.textContent = formatDate(date);
        countCell.textContent = historyData.history[date];
        
        row.appendChild(dateCell);
        row.appendChild(countCell);
        historyTableBody.appendChild(row);
      });

      renderHistoryChart(historyData);
    }

    function showPlayerListModal(server) {
      playerListServerName.textContent = server.name || '未知服务器';
      playerListServerInfo.textContent = `${server.ip}:${server.port} | ${server.isp || '-'}`;

      if (server.players && server.players.length > 0) {
        playerListTableBody.innerHTML = '';
        server.players.forEach(player => {
          const row = document.createElement('tr');
          row.innerHTML = `
            <td>${escapeHtml(player.name)}</td>
            <td>${player.duration}</td>
            <td>${player.score}</td>
          `;
          playerListTableBody.appendChild(row);
        });
        playerListNoData.style.display = 'none';
      } else {
        playerListTableBody.innerHTML = '';
        playerListNoData.style.display = 'block';
      }

      playerListModal.classList.add('show');
    }

    function hidePlayerListModal() {
      playerListModal.classList.remove('show');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function startLoadingAnimation(message = '已连接，等待服务器数据') {
      let dots = 1;
      clearInterval(loadingInterval);
      clearInterval(reconnectCountdownIntervalId);
      reconnectCountdownIntervalId = null;
      statusDiv.textContent = message + '.';
      loadingInterval = setInterval(() => {
        dots = (dots % 3) + 1;
        statusDiv.textContent = `${message}${'.'.repeat(dots)}`;
      }, 500);
    }

    function stopLoadingAnimation(message) {
      clearInterval(loadingInterval);
      loadingInterval = null;
      if (!reconnectCountdownIntervalId) {
        statusDiv.textContent = message;
      }
    }

    function showLoading() {
      if (!isLoading) {
        isLoading = true;
        loadingStartTime = Date.now();
        loadingOverlay.style.display = 'flex';
      }
    }

    function hideLoading() {
      const elapsed = Date.now() - loadingStartTime;
      const remaining = Math.max(0, minLoadingTime - elapsed);
      
      setTimeout(() => {
        isLoading = false;
        loadingOverlay.style.display = 'none';
      }, remaining);
    }

    function loadCachedData() {
      const cachedDataStr = sessionStorage.getItem('serverData');
      const cachedTagCacheStr = sessionStorage.getItem('tagCache');
      
      if (cachedTagCacheStr) {
        try {
          tagCache = new Map(JSON.parse(cachedTagCacheStr));
        } catch (e) {
          console.error("Failed to parse cached tag cache:", e);
          tagCache = new Map();
        }
      }
      
      if (cachedDataStr) {
        try {
          const cachedData = JSON.parse(cachedDataStr);
          if (Array.isArray(cachedData)) {
            cachedData.forEach(server => {
              const key = `${server.ip}:${server.port}`;
              // 应用标签缓存
              if (tagCache.has(key)) {
                server.tags = tagCache.get(key).tags;
              }
              serverData.set(key, server);
            });
            updateFiltersFromData();
            applyUrlParamsToFilters();
            debouncedFilterAndRender();
            updateStatus();
          } else {
            sessionStorage.removeItem('serverData');
          }
        } catch (e) {
          console.error("Failed to parse cached data:", e);
          sessionStorage.removeItem('serverData');
        }
      }
      applyUrlParamsToFilters();
      debouncedFilterAndRender();
    }

    function addOrUpdateServer(server) {
      if (!server || typeof server.ip !== 'string' || typeof server.port !== 'number') {
        console.warn("Received invalid server data:", server);
        return false;
      }
      const gameDesc = server.game_description || '-';
      if (gameDesc === '-') return false;
      const key = `${server.ip}:${server.port}`;
      
      // 应用标签缓存逻辑
      server.tags = processTagsWithCache(key, server.tags);
      
      serverData.set(key, server);

      const regionDesc = server.country || 'unknown';
      let filtersChanged = false;
      if (!uniqueGames.has(gameDesc)) {
        uniqueGames.add(gameDesc);
        filtersChanged = true;
      }
      if (!uniqueRegions.has(regionDesc)) {
        uniqueRegions.add(regionDesc);
        filtersChanged = true;
      }
      if (filtersChanged) {
        updateFilterOptionsUI();
        applyUrlParamsToFilters();
      }
      return true;
    }

    function updateStatus() {
      const serverCount = serverData.size;
      const gameCount = uniqueGames.size;
      const regionCount = uniqueRegions.size;
      if (!reconnectCountdownIntervalId) {
        stopLoadingAnimation(`已加载 ${serverCount} 个服务器，${gameCount} 个游戏，${regionCount} 个地区。`);
      }
    }

    function connectWebSocket() {
      if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
        return;
      }
      clearTimeout(reconnectTimeoutId);
      reconnectTimeoutId = null;
      clearInterval(reconnectCountdownIntervalId);
      reconnectCountdownIntervalId = null;

      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
      statusDiv.textContent = '正在连接服务器...';

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        reconnectDelay = 5000;
        clearInterval(reconnectCountdownIntervalId);
        reconnectCountdownIntervalId = null;
        startLoadingAnimation();
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'visitor_count') {
            visitorCountDiv.textContent = `${data.count} 位访客`;
          } else {
            const dataAdded = addOrUpdateServer(data);
            if (dataAdded) {
              debouncedFilterAndRender();
            }
          }
        } catch (e) {
          console.error("Error processing WebSocket message:", e, "Data:", event.data);
        }
      };
      
      const debouncedFullUpdate = debounce(() => {
        updateStatus();
        updateLastUpdateTime();
        sessionStorage.setItem('serverData', JSON.stringify(Array.from(serverData.values())));
        // 保存标签缓存
        sessionStorage.setItem('tagCache', JSON.stringify(Array.from(tagCache.entries())));
        if (isLoading) {
          hideLoading();
        }
      }, 500);
      
      ws.addEventListener('message', debouncedFullUpdate);

      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
      };

      ws.onclose = (event) => {
        ws = null;
        if (event.code === 1000 || event.code === 1001) {
          stopLoadingAnimation('WebSocket 连接已关闭。');
          clearInterval(reconnectCountdownIntervalId);
          reconnectCountdownIntervalId = null;
          return;
        }
        clearInterval(loadingInterval);
        clearInterval(reconnectCountdownIntervalId);

        const reconnectAttemptTime = Date.now() + reconnectDelay;
        const updateCountdown = () => {
          const now = Date.now();
          const secondsRemaining = Math.ceil((reconnectAttemptTime - now) / 1000);
          if (secondsRemaining > 0) {
            statusDiv.textContent = `连接已断开，${secondsRemaining}秒后尝试重新连接...`;
          } else {
            statusDiv.textContent = '正在尝试重新连接...';
            clearInterval(reconnectCountdownIntervalId);
            reconnectCountdownIntervalId = null;
          }
        };
        updateCountdown();
        reconnectCountdownIntervalId = setInterval(updateCountdown, 1000);

        reconnectTimeoutId = setTimeout(connectWebSocket, reconnectDelay);
        reconnectDelay = Math.min(reconnectDelay * 2, maxReconnectDelay);
      };
    }

    function updateFiltersFromData() {
      uniqueGames.clear();
      uniqueRegions.clear();
      serverData.forEach(server => {
        uniqueGames.add(server.game_description || '-');
        uniqueRegions.add(server.country || 'unknown');
      });
      updateFilterOptionsUI();
    }

    function updateFilterOptionsUI() {
      const sortedGames = Array.from(uniqueGames).sort();
      const sortedRegions = Array.from(uniqueRegions).sort();
      initializeFilterOptions(gameFilterOptions, sortedGames, getSelectedGames());
      initializeFilterOptions(regionFilterOptions, sortedRegions, getSelectedRegions(), true);
      updateGameFilterButtonText();
      updateRegionFilterButtonText();
    }

    function applyUrlParamsToFilters() {
      let selectedGames = initialSelectedGames;
      let selectedRegions = initialSelectedRegions;

      if (serverData.size > 0) {
        selectedGames = selectedGames.filter(g => uniqueGames.has(g));
        selectedRegions = selectedRegions.filter(r => uniqueRegions.has(r));
      }

      applyCheckboxSelection(gameFilterOptions, selectedGames);
      applyCheckboxSelection(regionFilterOptions, selectedRegions);
      updateGameFilterButtonText();
      updateRegionFilterButtonText();
      currentSort = ['players', 'name', 'latency'].includes(urlParams.sort) ? urlParams.sort : 'players';
      sortBtn.textContent = {'players': '按人数排序', 'name': '按名称排序', 'latency': '按延迟排序'}[currentSort];

      searchFilter = urlParams.filter || '';
      searchInput.value = searchFilter;
    }

    function applyCheckboxSelection(optionsContainer, selectedValues) {
      const checkboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb => { cb.checked = selectedValues.includes(cb.value); });
    }

    function initializeFilterOptions(optionsContainer, items, selectedItems, isRegion = false) {
      optionsContainer.innerHTML = '';
      items.forEach(item => {
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = item;
        checkbox.checked = selectedItems.includes(item);
        checkbox.addEventListener('change', () => {
          currentPage = 1;
          debouncedFilterAndRender();
          if (isRegion) updateRegionFilterButtonText();
          else updateGameFilterButtonText();
          updateURL();
        });
        label.appendChild(checkbox);
        if (isRegion && item !== 'unknown') {
          const flagImg = document.createElement('img');
          flagImg.src = `https://flagcdn.com/w40/${item.toLowerCase()}.png`;
          flagImg.alt = item;
          flagImg.className = 'flag-icon';
          flagImg.onerror = (e) => { e.target.style.display = 'none'; };
          label.appendChild(flagImg);
          label.appendChild(document.createTextNode(` ${item}`));
        } else {
          label.appendChild(document.createTextNode(item || '-'));
        }
        optionsContainer.appendChild(label);
      });
    }

    function getSelectedGames() {
      return Array.from(gameFilterOptions.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
    }

    function getSelectedRegions() {
      return Array.from(regionFilterOptions.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
    }

    function updateGameFilterButtonText() {
      const selectedGames = getSelectedGames();
      const count = selectedGames.length;
      if (count === 0) { gameFilterBtn.textContent = '选择游戏'; gameFilterBtn.title = ''; }
      else if (count === uniqueGames.size && serverData.size > 0) { gameFilterBtn.textContent = '所有游戏'; gameFilterBtn.title = '所有游戏'; }
      else { const joined = selectedGames.join(', '); gameFilterBtn.textContent = joined.substring(0, 15) + (joined.length > 15 ? '...' : ''); gameFilterBtn.title = joined; }
    }

    function updateRegionFilterButtonText() {
      const selectedRegions = getSelectedRegions();
      const count = selectedRegions.length;
      if (count === 0) { regionFilterBtn.textContent = '选择地区'; regionFilterBtn.title = ''; }
      else if (count === uniqueRegions.size && serverData.size > 0) { regionFilterBtn.textContent = '所有地区'; regionFilterBtn.title = '所有地区'; }
      else { const joined = selectedRegions.join(', '); regionFilterBtn.textContent = joined.substring(0, 15) + (joined.length > 15 ? '...' : ''); regionFilterBtn.title = joined; }
    }

    function toggleGameMultiselect() { gameFilter.classList.toggle('open'); regionFilter.classList.remove('open'); sortDropdown.classList.remove('open'); }
    function toggleRegionMultiselect() { regionFilter.classList.toggle('open'); gameFilter.classList.remove('open'); sortDropdown.classList.remove('open'); }
    function toggleDropdown() { sortDropdown.classList.toggle('open'); gameFilter.classList.remove('open'); regionFilter.classList.remove('open'); }

    function selectSort(method) {
      currentSort = ['players', 'name', 'latency'].includes(method) ? method : 'players';
      sortBtn.textContent = {'players': '按人数排序', 'name': '按名称排序', 'latency': '按延迟排序'}[currentSort];
      sortDropdown.classList.remove('open');
      debouncedFilterAndRender();
      updateURL();
    }

    function showTooltip(cell, name, event) {
      if (currentTooltip) {
        currentTooltip.remove();
        currentTooltip = null;
      }

      const tooltip = document.createElement('div');
      tooltip.className = 'tooltip';
      tooltip.textContent = name || '-';
      document.body.appendChild(tooltip);

      const rect = cell.getBoundingClientRect();
      const scrollX = window.scrollX || window.pageXOffset;
      const scrollY = window.scrollY || window.pageYOffset;
      
      const isMobile = window.matchMedia('(max-width: 680px)').matches;
      let x, y;

      if (isMobile && event.type === 'touchstart') {
        x = event.touches[0].clientX + scrollX;
        y = event.touches[0].clientY + scrollY + 10;
      } else {
        x = event.clientX + scrollX + 10;
        y = event.clientY + scrollY + 10;
      }

      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;

      const tooltipRect = tooltip.getBoundingClientRect();
      const viewportRight = scrollX + window.innerWidth;
      const viewportBottom = scrollY + window.innerHeight;
      const tooltipRight = x + tooltipRect.width;
      const tooltipBottom = y + tooltipRect.height;

      if (tooltipRight > viewportRight) {
        x = viewportRight - tooltipRect.width - 10;
      }
      if (tooltipBottom > viewportBottom) {
        y = viewportBottom - tooltipRect.height - 10;
      }

      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;

      setTimeout(() => tooltip.classList.add('visible'), 10);
      currentTooltip = tooltip;
    }

    function hideTooltip() {
      if (currentTooltip) {
        currentTooltip.remove();
        currentTooltip = null;
      }
    }

    function showSupportModal() {
      const modal = document.getElementById('supportModal');
      modal.classList.add('show');
    }

    function hideSupportModal() {
      const modal = document.getElementById('supportModal');
      modal.classList.remove('show');
    }

    function hideHistoryModal() {
      historyModal.classList.remove('show');
    }

    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString('zh-CN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
      });
    }

    function updatePagination(totalItems, currentPage, itemsPerPage) {
      totalPages = Math.ceil(totalItems / itemsPerPage);
      if (currentPage > totalPages) {
        currentPage = totalPages || 1;
      }
      
      paginationContainer.innerHTML = '';
      
      if (totalPages <= 1) return;

      const prevBtn = createPageBtn('上一页', currentPage > 1 ? currentPage - 1 : 1, currentPage === 1);
      paginationContainer.appendChild(prevBtn);

      const pages = [];

      if (currentPage - 2 >= 1) {
        pages.push(currentPage - 2);
      }

      if (currentPage - 1 >= 1) {
        pages.push(currentPage - 1);
      }

      pages.push(currentPage);

      if (currentPage + 1 <= totalPages) {
        pages.push(currentPage + 1);
      }

      if (currentPage + 2 <= totalPages) {
        pages.push(currentPage + 2);
      }

      const uniquePages = [...new Set(pages)].sort((a, b) => a - b);
      
      uniquePages.forEach(page => {
        const pageBtn = createPageBtn(page, page, page === currentPage);
        paginationContainer.appendChild(pageBtn);
      });

      const nextBtn = createPageBtn('下一页', currentPage < totalPages ? currentPage + 1 : totalPages, currentPage === totalPages);
      paginationContainer.appendChild(nextBtn);
    }
    
    function createPageBtn(text, page, disabled = false) {
      const btn = document.createElement('button');
      btn.className = 'page-btn';
      btn.textContent = text;
      
      if (disabled) {
        btn.classList.add('disabled');
      } else {
        btn.addEventListener('click', () => {
          currentPage = page;
          debouncedFilterAndRender();
          updateURL();
        });
      }
      
      if (page === currentPage) {
        btn.classList.add('active');
      }
      
      return btn;
    }

    function setupSearch() {
      searchInput.addEventListener('input', debounce(() => {
        searchFilter = searchInput.value.trim();
        currentPage = 1;
        debouncedFilterAndRender();
        updateURL();
      }, 300));
    }

    function filterServers(servers) {
      const selectedGames = getSelectedGames();
      const selectedRegions = getSelectedRegions();
      
      return servers.filter(server => {
        if (selectedGames.length > 0 && !selectedGames.includes(server.game_description || '-')) {
          return false;
        }

        if (selectedRegions.length > 0 && !selectedRegions.includes(server.country || 'unknown')) {
          return false;
        }

        if (searchFilter) {
          const serverName = (server.name || '').toLowerCase();
          const searchTerm = searchFilter.toLowerCase();
          if (!serverName.includes(searchTerm)) {
            return false;
          }
        }
        
        return true;
      });
    }

    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    const debouncedFilterAndRender = debounce(() => {
        filterAndRenderTable();
    }, 50);

    function filterAndRenderTable() {
      if (isRendering) return;

      let serversToRender = Array.from(serverData.values());

      serversToRender = filterServers(serversToRender);
      
      sortServers(serversToRender);

      updatePagination(serversToRender.length, currentPage, itemsPerPage);

      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      serversToRender = serversToRender.slice(startIndex, endIndex);

      if (tableContainer) {
        const currentHeight = tableContainer.scrollHeight;
        tableContainer.style.setProperty('--table-container-height', `${currentHeight}px`);
        tableContainer.classList.add('lock-height');
      }

      const serversKey = JSON.stringify(serversToRender.map(s => s.ip + ':' + s.port));
      if (serversKey === lastRenderedKey) {
        if (tableContainer) {
          setTimeout(() => {
            tableContainer.classList.remove('lock-height');
          }, 10);
        }
        return;
      }
      lastRenderedKey = serversKey;
      
      isRendering = true;
      requestAnimationFrame(() => {
        renderTable(serversToRender);
        isRendering = false;
      });
    }

    function sortServers(servers) {
      servers.sort((a, b) => {
        if (currentSort === 'players') {
          const diff = (b.current_players ?? -1) - (a.current_players ?? -1);
          if (diff) return diff;
          return (a.name || '').localeCompare(b.name || '');
        } else if (currentSort === 'name') {
          return (a.name || '').localeCompare(b.name || '');
        } else {
          const latA = a.latency ?? Infinity;
          const latB = b.latency ?? Infinity;
          const diff = latA - latB;
          if (diff) return diff;
          return (b.current_players ?? -1) - (a.current_players ?? -1);
        }
      });
    }

    function renderTable(servers) {
      const oldPositions = new Map();
      const existingRows = new Map();

      tbody.querySelectorAll('[data-key]').forEach(row => {
          oldPositions.set(row.dataset.key, row.getBoundingClientRect());
          existingRows.set(row.dataset.key, row);
      });
      
      const fragment = document.createDocumentFragment();
      const updatedKeys = new Set();
      const newRowsToAnimate = [];

      servers.forEach(server => {
          const key = `${server.ip}:${server.port}`;
          updatedKeys.add(key);
          const [dataRow, tagRow] = createRow(server);
          fragment.appendChild(dataRow);
          fragment.appendChild(tagRow);
          newRowsToAnimate.push(dataRow);
      });

      existingRows.forEach((row, key) => {
          if (!updatedKeys.has(key)) {
              row.classList.add('removing');
              setTimeout(() => row.remove(), 300);
          }
      });

      tbody.innerHTML = '';
      tbody.appendChild(fragment);

      newRowsToAnimate.forEach(row => row.classList.add('new-row'));

      const rowsToMove = [];
      tbody.querySelectorAll('[data-key]').forEach(row => {
          const oldPos = oldPositions.get(row.dataset.key);
          if (!oldPos || newRowsToAnimate.includes(row)) return;

          const newPos = row.getBoundingClientRect();
          const dx = oldPos.left - newPos.left;
          const dy = oldPos.top - newPos.top;

          if (dx !== 0 || dy !== 0) {
              row.style.transform = `translate(${dx}px, ${dy}px)`;
              rowsToMove.push(row);
          }
      });

      requestAnimationFrame(() => {
          rowsToMove.forEach(row => {
              row.classList.add('moving');
              row.style.transform = '';
          });

          rowsToMove.forEach(row => {
              row.addEventListener('transitionend', () => {
                  row.classList.remove('moving');
              }, { once: true });
          });
      });

      processLatencyUpdates();

      if (tableContainer) {
        if (scrollHideTimer) {
          clearTimeout(scrollHideTimer);
        }
        scrollHideTimer = setTimeout(() => {
          tableContainer.classList.remove('lock-height');
          scrollHideTimer = null;
        }, 500);
      }
    }

    function createRow(server) {
        const key = `${server.ip}:${server.port}`;

        const dataRow = document.createElement('tr');
        dataRow.dataset.key = key;
        dataRow.classList.toggle('zero-players', server.current_players === 0);

        const countryCode = (server.country || 'unknown').toLowerCase();
        const ipPort = `${server.ip}:${server.port}`;

        const cellCountry = dataRow.insertCell();
        cellCountry.className = 'country';
        if (countryCode !== 'unknown') {
            const flagImg = document.createElement('img');
            flagImg.src = `https://flagcdn.com/w40/${countryCode}.png`;
            flagImg.alt = server.country || '';
            flagImg.className = 'flag-icon';
            flagImg.onerror = e => { e.target.style.display = 'none'; cellCountry.textContent = countryCode.toUpperCase(); };
            cellCountry.appendChild(flagImg);
        } else {
            cellCountry.textContent = '?';
        }

        createCell(dataRow, 'game', server.game_description || '-');
        const cellName = createCell(dataRow, 'name', server.name || '-');
        cellName.addEventListener('mouseenter', e => showTooltip(cellName, server.name, e));
        cellName.addEventListener('mouseleave', hideTooltip);
        cellName.addEventListener('click', () => showHistoryModal(server));
        cellName.addEventListener('touchstart', e => { e.preventDefault(); showHistoryModal(server); });
        
        const cellIp = createCell(dataRow, 'ip');
        const link = document.createElement('a');
        link.href = `steam://connect/${ipPort}`;
        link.className = 'ip-link';
        link.textContent = ipPort;
        cellIp.appendChild(link);

        createCell(dataRow, 'isp', server.isp || '-');
        createCell(dataRow, 'os', server.os || '-');
        createCell(dataRow, 'players', `${server.current_players ?? '?'}/${server.max_players ?? '?'}`);
        createCell(dataRow, 'map', server.map || '-');
        createCell(dataRow, 'version', server.version || '-');
        createCell(dataRow, 'latency', server.latency ?? '-');

        const tagRow = document.createElement('tr');
        tagRow.className = 'tag-row';
        tagRow.dataset.key = key + '-tags';
        const tagCell = document.createElement('td');
        tagCell.colSpan = 10;
        const tagContainer = document.createElement('div');
        tagContainer.className = 'tag-container';
        
        if (server.tags && server.tags.length > 0) {
          server.tags.forEach(tag => {
            const tagElement = document.createElement('span');
            tagElement.className = 'tag';
            tagElement.textContent = tag;
            const tagColor = getTagColor(tag);
            tagElement.style.borderColor = tagColor; // 不透明边框
            tagContainer.appendChild(tagElement);
          });
        } else {
          const noTags = document.createElement('span');
          noTags.textContent = '无标签';
          noTags.style.color = 'var(--muted)';
          noTags.style.fontStyle = 'italic';
          tagContainer.appendChild(noTags);
        }
        
        tagCell.appendChild(tagContainer);
        tagRow.appendChild(tagCell);

        return [dataRow, tagRow];
    }

    function updateCellContent(cell, newContent) {
      const str = String(newContent);
      if (cell.textContent !== str) {
        cell.textContent = str;
      }
    }

    function queueLatencyUpdate(cell, newLatency, key) {
      const currentLatency = cell.textContent;
      const newStr = String(newLatency);
      if (currentLatency !== newStr) {
          latencyUpdateQueue.set(key, { cell, newLatency: newStr });
      }
    }

    const processLatencyUpdates = debounce(() => {
      latencyUpdateQueue.forEach(({ cell, newLatency }) => {
        if (cell.textContent !== newLatency) {
          cell.textContent = newLatency;
          cell.classList.add('updated');
          setTimeout(() => cell.classList.remove('updated'), 600);
        }
      });
      latencyUpdateQueue.clear();
    }, 200);

    function createCell(row, className, text = '') {
      const cell = row.insertCell();
      cell.className = className;
      cell.textContent = text;
      return cell;
    }

    function updateLastUpdateTime() {
      lastUpdateTime = Date.now();
      lastUpdatedDiv.classList.remove('hidden');
      updateTimeSpan.textContent = '0';
    }

    function startUpdateTimer() {
      clearInterval(updateTimerInterval);
      updateTimerInterval = setInterval(() => {
        if (lastUpdateTime) {
          const sec = Math.floor((Date.now() - lastUpdateTime) / 1000);
          updateTimeSpan.textContent = sec;
        }
      }, 1000);
    }

    async function refreshServers() {
      const btn = document.querySelector('.refresh-btn');
      btn.disabled = true;
      const orig = statusDiv.textContent;
      if (!reconnectCountdownIntervalId) startLoadingAnimation('正在请求刷新...');

      try {
        await axios.get('/api/servers');
        setTimeout(() => {
          btn.disabled = false;
          if (!reconnectCountdownIntervalId && statusDiv.textContent.startsWith('正在请求刷新')) {
            statusDiv.textContent = orig;
          }
        }, 3000);
      } catch (e) {
        console.error("Error requesting server refresh:", e);
        if (!reconnectCountdownIntervalId) stopLoadingAnimation('刷新请求失败');
        btn.disabled = false;
      }
    }

    window.onload = () => {
      showLoading();
      urlParams = parseURLParams();
      loadCachedData();
      startUpdateTimer();
      connectWebSocket();
      setupSearch();

      document.addEventListener('click', (e) => {
        if (currentTooltip && !e.target.closest('.name')) {
          hideTooltip();
        }
        const modal = document.getElementById('supportModal');
        if (modal.classList.contains('show') && e.target === modal) {
          hideSupportModal();
        }
        
        const historyModal = document.getElementById('historyModal');
        if (historyModal.classList.contains('show') && e.target === historyModal) {
          hideHistoryModal();
        }
        
        const playerListModal = document.getElementById('playerListModal');
        if (playerListModal.classList.contains('show') && e.target === playerListModal) {
          hidePlayerListModal();
        }
        
        if (!gameFilter.contains(e.target)) gameFilter.classList.remove('open');
        if (!regionFilter.contains(e.target)) regionFilter.classList.remove('open');
        if (!sortDropdown.contains(e.target)) sortDropdown.classList.remove('open');
      });
    };
  </script>
</body>
</html>