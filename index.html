<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>服务器列表</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Great+Vibes&display=swap" rel="stylesheet">
  <!-- 引入Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{
      --bg:#07080a;
      --muted:#9aa3b2;
      --text:#d7e1ea;
      --accent:#6ee7b7;
      --accent-2:#4fd6a6;
      --glass-border: rgba(255,255,255,0.04);
      --radius:12px;
      --shadow-strong: 0 8px 30px rgba(2,6,23,0.7);
      --ease: cubic-bezier(.16,.84,.3,1);
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:"Inter",Arial,sans-serif;-webkit-font-smoothing:antialiased;background:var(--bg);color:var(--text)}
    body::before{
      content:"";
      position:fixed;
      inset:-20%;
      z-index:-2;
      background:
        radial-gradient(800px 400px at 10% 20%, rgba(110,231,183,0.06), transparent 15%),
        radial-gradient(700px 350px at 85% 80%, rgba(120,126,255,0.04), transparent 10%),
        conic-gradient(from 180deg at 50% 50%, rgba(255,255,255,0.01), rgba(0,0,0,0.02));
      filter: blur(40px) saturate(105%);
      transform: rotate(-2deg);
      animation: bgDrift 18s linear infinite alternate;
    }
    @keyframes bgDrift { 0% { transform: translateY(0) scale(1) rotate(-2deg); } 100% { transform: translateY(-8px) scale(1.02) rotate(-1deg); } }

    .app{ max-width:1200px; width: calc(100% - 56px); margin:28px auto; padding:20px; border-radius:16px; background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00)); box-shadow: var(--shadow-strong); position:relative; overflow:visible; border:1px solid rgba(255,255,255,0.02); backdrop-filter: blur(6px) saturate(1.05); }

    .header{ display:flex; align-items:center; gap:16px; margin-bottom:16px; position: relative; }
    .logo{ width:64px; height:64px; border-radius:10px; background: linear-gradient(135deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); display:flex; align-items:center; justify-content:center; border:1px solid var(--glass-border); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02), 0 6px 18px rgba(2,6,23,0.6); flex-shrink:0 }
    .title-wrap{ flex:1; min-width:0 }
    .title{ font-size:18px; font-weight:600; color:var(--text); margin:0; }
    .subtitle{ margin-top:4px; color:var(--muted); font-size:13px }
    .visitor-count{ 
      position: absolute; 
      right: 0; 
      top: 0; 
      padding: 6px 12px; 
      background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.008)); 
      border-radius: 8px; 
      border: 1px solid rgba(255,255,255,0.03); 
      color: var(--text); 
      font-size: 13px; 
      font-weight: 600; 
      box-shadow: 0 4px 12px rgba(2,6,23,0.4); 
    }

    .controls{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; padding:12px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.008)); border:1px solid var(--glass-border); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); margin-bottom:16px; }

    .btn{ appearance:none; border:none; outline:none; padding:10px 14px; border-radius:10px; background: linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.008)); color:var(--text); font-weight:600; font-size:13px; cursor:pointer; border:1px solid rgba(255,255,255,0.03); box-shadow:0 6px 18px rgba(2,6,23,0.5); transition: transform .14s var(--ease), box-shadow .14s var(--ease); display:inline-flex; align-items:center; gap:8px; min-height:40px; }
    .btn:hover{ transform: translateY(-3px); box-shadow: 0 12px 30px rgba(2,6,23,0.65); }
    .btn:active{ transform: translateY(-1px) scale(.997); }

    .refresh-btn{ background: linear-gradient(180deg, rgba(110,231,183,0.06), rgba(110,231,183,0.02)); border:1px solid rgba(110,231,183,0.12); color:var(--text); padding:10px 18px; border-radius:10px; font-weight:700; }
    .refresh-btn:disabled{ opacity:0.5; transform:none; cursor:not-allowed; box-shadow:none; }

    .dropdown, .multiselect{ position:relative; display:inline-block; min-width:150px; }
    .dropdown-btn, .multiselect-btn{ width:100%; text-align:left; padding:10px 14px; border-radius:10px; background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.03); cursor:pointer; font-weight:600; font-size:13px; }
    .dropdown-btn::after, .multiselect-btn::after { content: '▾'; float:right; opacity:0.8; font-size:12px; transition: transform .18s var(--ease); }
    .dropdown.open .dropdown-btn::after, .multiselect.open .multiselect-btn::after { transform: rotate(180deg); }

    .dropdown-content, .multiselect-content{
      position:absolute; top:calc(100% + 10px); left:0;
      min-width:220px; max-width:360px;
      background: rgba(14,16,18,0.96);
      color:var(--text);
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.06);
      box-shadow: 0 18px 60px rgba(0,0,0,0.75);
      padding:8px;
      z-index:120;
      transform-origin: top center;
      opacity:0; pointer-events:none;
      transform: translateY(-6px) scale(.98);
      transition: opacity .18s var(--ease), transform .18s var(--ease);
      backdrop-filter: blur(12px) saturate(1.05);
    }
    .dropdown.open .dropdown-content, .multiselect.open .multiselect-content { opacity:1; pointer-events:auto; transform: translateY(0) scale(1); }

    .dropdown-content div, .multiselect-content label { display:flex; gap:8px; align-items:center; padding:8px 10px; border-radius:8px; cursor:pointer; color:var(--text); font-size:13px; }
    .dropdown-content div:hover, .multiselect-content label:hover { background: rgba(255,255,255,0.02); }
    .multiselect-content{ max-height:320px; overflow:auto; width:260px; }
    .multiselect-content input[type="checkbox"] { width:16px; height:16px; accent-color:var(--accent); flex-shrink:0; }
    .flag-icon{ width:28px; height:18px; border-radius:3px; object-fit:cover; flex-shrink:0; }

    .status-container{ display:flex; align-items:center; gap:12px; margin:6px 0 16px; position:relative; min-height:48px; padding:8px 12px; border-radius:12px; border:1px solid var(--glass-border); background: linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.004)); }
    .status{ color:var(--text); font-weight:600; font-size:14px; }
    .last-updated{ color:var(--muted); font-size:13px; }
    .powered-by-wrap{ margin-left:auto; display:flex; flex-direction:column; align-items:flex-end; }
    .powered-by{ font-family:'Great Vibes', cursive; color:var(--accent-2); font-size:16px; text-shadow: 0 1px 0 rgba(0,0,0,0.6); position: relative; top: -4px; }
    .powered-by a { color:var(--accent-2); text-decoration:none; }
    .powered-by a:hover { text-decoration:underline; opacity:0.95; }
    .support-link { 
      font-size: 13px; 
      color: var(--accent); 
      cursor: pointer; 
      text-decoration: none; 
      transition: color 0.2s var(--ease); 
    }
    .support-link:hover { color: var(--text); text-decoration: underline; }

    /* --- Modal Styles --- */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(8px);
      z-index: 150;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s var(--ease);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .modal.show {
      opacity: 1;
      pointer-events: auto;
    }
    .modal-content {
      position: relative;
      background: rgba(14,16,18,0.96);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 18px 60px rgba(0,0,0,0.75);
      padding: 24px;
      padding-top: 56px; /* Extra space for close button */
      max-width: 550px; /* Reduced width */
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      text-align: center;
      transform: scale(0.95);
      transition: transform 0.3s var(--ease);
    }
    .modal.show .modal-content {
      transform: scale(1);
    }
    .modal-content img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    .modal-content p {
      color: var(--text);
      font-size: 14px;
      line-height: 1.5;
      margin: 0 0 16px;
    }
    .close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 32px;
      height: 32px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--glass-border);
      border-radius: 50%;
      color: var(--muted);
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s var(--ease);
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      padding: 0;
    }
    .close-btn:hover {
      color: var(--text);
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.1) rotate(90deg);
    }

    /* 服务器历史数据模态框样式 */
    .history-modal .modal-content {
      max-width: 800px;
      padding: 24px;
      padding-top: 56px;
      text-align: left;
    }
    .history-header {
      margin-bottom: 20px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      padding-bottom: 15px;
    }
    .history-title {
      font-size: 20px;
      margin: 0 0 8px 0;
      color: var(--accent);
    }
    .history-subtitle {
      color: var(--muted);
      margin: 0;
      font-size: 14px;
    }
    .history-chart-container {
      margin-bottom: 20px;
      position: relative;
      height: 300px;
    }
    .history-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    .history-table th,
    .history-table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .history-table th {
      color: var(--muted);
      font-weight: 600;
      font-size: 13px;
    }
    .history-table td {
      color: var(--text);
      font-size: 13px;
    }
    .history-table tr:last-child td {
      border-bottom: none;
    }
    .no-data {
      text-align: center;
      color: var(--muted);
      padding: 40px 0;
      font-style: italic;
    }

    .table-container{ 
      overflow-x: hidden; 
      overflow-y: hidden; /* 修复：始终隐藏垂直滚动条 */
      border-radius:12px; 
      padding:6px; 
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.003)); 
      border:1px solid rgba(255,255,255,0.02); 
      transition: overflow-y 0.3s ease; /* 平滑过渡效果 */
    }
    
    /* 添加一个类用于在渲染期间锁定高度 */
    .table-container.lock-height {
      height: var(--table-container-height);
      overflow-y: hidden !important;
    }

    table{ width:100%; border-collapse:separate; border-spacing:0; background:transparent; table-layout:auto; }

    thead th{
      position: sticky; top:0;
      background: linear-gradient(180deg, rgba(255,255,255,0.014), rgba(255,255,255,0.006));
      color:var(--muted); font-weight:700; font-size:13px;
      padding:12px 10px; text-align:left; border-bottom:1px solid rgba(255,255,255,0.03);
      backdrop-filter: blur(4px); z-index:8;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      writing-mode: horizontal-tb;
    }

    /* --- Table Row Animation Styles --- */
    tbody tr{
      background: linear-gradient(180deg, rgba(255,255,255,0.006), rgba(255,255,255,0.002));
      border-bottom:1px solid rgba(255,255,255,0.02); color:var(--text);
      /* Use a single transition for transform for FLIP to work smoothly */
      transition: background .22s var(--ease), box-shadow .22s var(--ease), opacity 0.3s var(--ease);
      will-change: transform, opacity; /* Performance hint for the browser */
    }
    tbody tr.moving {
        transition: transform 0.5s var(--ease); /* This class will be added during FLIP animation */
    }
    tbody tr:hover{ 
        /* Avoid transform on hover to not interfere with FLIP */
        box-shadow: 0 14px 30px rgba(2,6,23,0.55); 
        background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); 
        color:#fff; 
    }
    tbody tr.new-row { 
        animation: rowPopIn 0.4s var(--ease) forwards;
    }
    @keyframes rowPopIn {
        0% { transform: translateY(10px) scale(0.98); opacity: 0; }
        100% { transform: translateY(0) scale(1); opacity: 1; }
    }
    tbody tr.removing {
      opacity: 0;
      transform: translateX(-20px) scale(0.98);
      transition: transform 0.3s var(--ease), opacity 0.3s var(--ease);
    }
    /* --- End Animation Styles --- */

    td{ padding:10px; font-size:13px; vertical-align:middle; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; writing-mode: horizontal-tb; }
    td.name { cursor: pointer; }
    td.latency { transition: color .3s var(--ease); }
    td.latency.updated { animation: color-flash 0.6s var(--ease); }
    @keyframes color-flash {
        0%, 100% { color: var(--text); }
        50% { color: var(--accent); }
    }

    th.game, td.game { white-space:normal; overflow-wrap:anywhere; word-break:break-word; min-width:140px; max-width:200px; width:12%; }
    th.name, td.name { white-space:normal; overflow-wrap:anywhere; word-break:break-word; min-width:160px; max-width:220px; width:30%; }
    th.ip, td.ip { white-space:normal; overflow-wrap:anywhere; word-break:break-word; min-width:120px; max-width:160px; width:19%; }
    th.isp, td.isp { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; min-width:110px; max-width:150px; width:8%; }
    th.os, td.os { white-space:normal; overflow-wrap:anywhere; word-break:break-word; min-width:80px; max-width:100px; width:8%; }
    th.players, td.players { white-space:normal; word-break:normal; min-width:80px; max-width:100px; width:8%; text-align:center; }
    th.map, td.map { white-space:nowrap; min-width:72px; max-width:100px; width:7%; text-align:center; }
    th.version, td.version { white-space:normal; overflow-wrap:anywhere; min-width:90px; max-width:120px; width:8%; text-align:center; }
    th.latency, td.latency { white-space:normal; min-width:70px; max-width:90px; width:6%; text-align:center; }
    th.country, td.country { width:56px; max-width:60px; text-align:center; white-space:nowrap; min-width:56px; }

    tr.zero-players td{ opacity:0.78; color:var(--muted); filter:grayscale(.2); }

    .ip-link{ color:var(--text); text-decoration:none; font-weight:600; }
    .ip-link:hover{ text-decoration:underline; color:var(--accent); }

    .badge{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; font-size:12px; font-weight:700; background: rgba(255,255,255,0.01); border:1px solid rgba(255,255,255,0.02); }
    .badge.latency{ color:var(--muted); min-width:68px; justify-content:center; }
    .badge.players{ color:var(--text); background: linear-gradient(90deg, rgba(110,231,183,0.06), rgba(110,231,183,0.02)); border:1px solid rgba(110,231,183,0.08); }

    .footer-links{ margin-top:22px; color:var(--muted); text-align:center; font-size:13px; display:flex; gap:12px; justify-content:center; flex-wrap:wrap; }
    .footer-links a{ color:var(--muted); text-decoration:none; border-bottom:1px dashed rgba(255,255,255,0.02); padding-bottom:2px; }
    .footer-links a:hover{ color:var(--text); border-bottom-color: rgba(255,255,255,0.04); }

    .tooltip {
      position: absolute;
      background: rgba(14,16,18,0.96);
      color: var(--text);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 8px 20px rgba(0,0,0,0.5);
      padding: 8px 12px;
      font-size: 13px;
      z-index: 130;
      max-width: 300px;
      white-space: normal;
      word-break: break-word;
      pointer-events: none;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity .2s var(--ease), transform .2s var(--ease);
    }
    .tooltip.visible {
      opacity: 1;
      transform: translateY(0);
    }

    @media (max-width: 680px) {
      .app { width: calc(100% - 24px); padding:12px; margin:12px auto; max-width:none; }
      .controls { flex-direction:column; align-items:stretch; gap:10px; }
      .dropdown, .multiselect { width:100%; }
      .visitor-count { 
        position: static; 
        margin-left: auto; 
        font-size: 12px; 
        padding: 4px 8px; 
      }
      .powered-by-wrap { align-items: flex-end; }
      table thead th:nth-child(4),
      table tbody td:nth-child(4),
      table thead th:nth-child(5),
      table tbody td:nth-child(5),
      table thead th:nth-child(6),
      table tbody td:nth-child(6),
      table thead th:nth-child(8),
      table tbody td:nth-child(8),
      table thead th:nth-child(9),
      table tbody td:nth-child(9),
      table thead th:nth-child(10),
      table tbody td:nth-child(10) {
        display:none;
      }
      table { table-layout: fixed; width: 100%; }
      table thead th:nth-child(1), table tbody td:nth-child(1) { width: 15%; min-width: 50px; }
      table thead th:nth-child(2), table tbody td:nth-child(2) { width: 35%; min-width: 100px; }
      table thead th:nth-child(3), table tbody td:nth-child(3) { width: 35%; min-width: 90px; }
      table thead th:nth-child(7), table tbody td:nth-child(7) { width: 15%; min-width: 60px; }
      th.country, th.players {
        white-space: nowrap;
        overflow: visible;
        text-overflow: unset;
        font-size: 12px;
        padding: 8px 4px;
        text-align: center;
      }
      th.game, td.game,
      th.name, td.name {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        writing-mode: horizontal-tb;
        font-size: 12px;
        padding: 8px 4px;
      }
      td.country {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 8px 4px;
      }
      td.country img.flag-icon {
        width: 24px;
        height: 16px;
        margin: 0 auto;
      }
      td.country:not(:has(img)) {
        font-size: 12px;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      td.players {
        text-align: center;
        font-size: 12px;
        padding: 8px 4px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      thead th:nth-child(1), tbody td:nth-child(1),
      thead th:nth-child(2), tbody td:nth-child(2),
      thead th:nth-child(3), tbody td:nth-child(3),
      thead th:nth-child(7), tbody td:nth-child(7) {
        display: table-cell;
        writing-mode: horizontal-tb;
      }
      .logo { display: none; }
      .title { font-size: 16px; }
      .table-container { overflow: visible; }
      .tooltip {
        max-width: 90%;
        font-size: 12px;
        padding: 6px 10px;
      }
      .history-modal .modal-content {
        padding: 16px;
        padding-top: 48px;
      }
      .history-title {
        font-size: 18px;
      }
      .history-chart-container {
        height: 200px;
      }
    }

    .multiselect-content::-webkit-scrollbar, .dropdown-content::-webkit-scrollbar { height:10px; width:10px; }
    .multiselect-content::-webkit-scrollbar-thumb, .dropdown-content::-webkit-scrollbar-thumb {
      border-radius:6px;
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border:2px solid rgba(0,0,0,0.12);
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="header" role="banner">
      <div class="logo" aria-hidden="true">
        <svg width="44" height="44" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="20" height="20" rx="5" fill="rgba(255,255,255,0.02)"/><path d="M7 12h10M7 8h10M7 16h6" stroke="rgba(110,231,183,0.9)" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </div>
      <div class="title-wrap">
        <h1 class="title">服务器列表</h1>
        <div class="subtitle">实时显示游戏服务器 — 支持筛选、排序与连接</div>
      </div>
      <div class="visitor-count" id="visitorCount">0 位访客</div>
    </header>

    <div class="controls" role="region" aria-label="Controls">
      <button class="btn refresh-btn" onclick="refreshServers()" title="手动请求服务器更新其状态">刷新列表</button>

      <div class="multiselect" id="regionFilter">
        <button class="multiselect-btn" onclick="toggleRegionMultiselect()">选择地区</button>
        <div class="multiselect-content" id="regionFilterOptions" aria-hidden="true"></div>
      </div>

      <div class="multiselect" id="gameFilter">
        <button class="multiselect-btn" onclick="toggleGameMultiselect()">选择游戏</button>
        <div class="multiselect-content" id="gameFilterOptions" aria-hidden="true"></div>
      </div>

      <div class="dropdown" id="sortDropdown">
        <button class="dropdown-btn" onclick="toggleDropdown()">按人数排序</button>
        <div class="dropdown-content" id="sortOptions" role="menu" aria-hidden="true">
          <div onclick="selectSort('players')" role="menuitem">按人数排序</div>
          <div onclick="selectSort('name')" role="menuitem">按名称排序</div>
          <div onclick="selectSort('latency')" role="menuitem">按延迟排序</div>
        </div>
      </div>
    </div>

    <div class="status-container" role="status" aria-live="polite">
      <div class="status" id="status">正在初始化...</div>
      <div class="last-updated hidden">最后更新于 <span id="updateTime">0</span> 秒之前</div>
      <div class="powered-by-wrap">
        <div class="powered-by"><a href="https://github.com/zetsr/Steam-Server-Web-Browser" target="_blank" rel="noopener noreferrer">Powered by zetsr</a></div>
        <a class="support-link" onclick="showSupportModal()">支持一下♥</a>
      </div>
    </div>

    <div class="table-container" aria-label="Server Table">
      <table id="serverTable" role="table" aria-describedby="status">
        <thead>
          <tr>
            <th class="country">国家</th>
            <th class="game">游戏名称</th>
            <th class="name">服务器名称</th>
            <th class="ip">服务器IP</th>
            <th class="isp">服务商</th>
            <th class="os">操作系统</th>
            <th class="players">在线玩家</th>
            <th class="map">地图</th>
            <th class="version">版本</th>
            <th class="latency">延迟 (ms)</th>
          </tr>
        </thead>
        <tbody id="serverList"></tbody>
      </table>
    </div>

    <div class="footer-links">
      <div><a href="https://ipinfo.io" target="_blank" rel="noopener noreferrer">IP Data by ipinfo.io</a></div>
      <div><a href="https://developer.valvesoftware.com/wiki/Master_Server_Query_Protocol" target="_blank" rel="noopener noreferrer">Valve Master Server</a></div>
      <div><a href="https://developer.valvesoftware.com/wiki/Server_queries" target="_blank" rel="noopener noreferrer">A2S Server Queries</a></div>
    </div>
  </div>
  <div class="modal" id="supportModal">
    <div class="modal-content">
      <button class="close-btn" onclick="hideSupportModal()">×</button>
      <img src="pay.jpg" alt="赞助二维码">
      <p>您的赞助将帮助我们维持服务器的运行和持续改进服务。扫描上方二维码即可赞助我们，感谢您的支持！</p>
    </div>
  </div>

  <!-- 新增：服务器历史数据模态框 -->
  <div class="modal history-modal" id="historyModal">
    <div class="modal-content">
      <button class="close-btn" onclick="hideHistoryModal()">×</button>
      <div class="history-header">
        <h2 class="history-title" id="historyServerName">服务器名称</h2>
        <p class="history-subtitle" id="historyServerInfo">IP:端口</p>
      </div>
      <div class="history-chart-container">
        <canvas id="historyChart"></canvas>
      </div>
      <div id="historyTableContainer">
        <table class="history-table">
          <thead>
            <tr>
              <th>日期</th>
              <th>最大在线人数</th>
            </tr>
          </thead>
          <tbody id="historyTableBody">
          </tbody>
        </table>
      </div>
      <div class="no-data" id="historyNoData" style="display: none;">
        暂无最近30天的历史数据
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script>
    const tbody = document.getElementById('serverList');
    const statusDiv = document.getElementById('status');
    const gameFilter = document.getElementById('gameFilter');
    const gameFilterBtn = gameFilter.querySelector('.multiselect-btn');
    const gameFilterOptions = document.getElementById('gameFilterOptions');
    const regionFilter = document.getElementById('regionFilter');
    const regionFilterBtn = regionFilter.querySelector('.multiselect-btn');
    const regionFilterOptions = document.getElementById('regionFilterOptions');
    const sortDropdown = document.getElementById('sortDropdown');
    const sortBtn = sortDropdown.querySelector('.dropdown-btn');
    const updateTimeSpan = document.getElementById('updateTime');
    const lastUpdatedDiv = document.querySelector('.last-updated');
    const visitorCountDiv = document.getElementById('visitorCount');
    const tableContainer = document.querySelector('.table-container');

    // 新增：历史数据相关元素
    const historyModal = document.getElementById('historyModal');
    const historyServerName = document.getElementById('historyServerName');
    const historyServerInfo = document.getElementById('historyServerInfo');
    const historyChart = document.getElementById('historyChart');
    const historyTableBody = document.getElementById('historyTableBody');
    const historyNoData = document.getElementById('historyNoData');
    const historyTableContainer = document.getElementById('historyTableContainer');

    let serverData = new Map();
    let uniqueGames = new Set();
    let uniqueRegions = new Set();
    let currentSort = 'players';
    let urlParams = parseURLParams();
    let initialSelectedGames = urlParams.games;
    let initialSelectedRegions = urlParams.regions;
    let loadingInterval = null;
    let lastUpdateTime = null;
    let updateTimerInterval = null;
    let currentTooltip = null;
    let lastRenderedKey = null; // Changed from lastRenderedServers to lastRenderedKey
    let latencyUpdateQueue = new Map();
    let isRendering = false; // A flag to prevent concurrent rendering
    let scrollHideTimer = null;

    let ws = null;
    let reconnectDelay = 5000;
    const maxReconnectDelay = 60000;
    let reconnectTimeoutId = null;
    let reconnectCountdownIntervalId = null;

    // 新增：Chart.js 实例
    let historyChartInstance = null;

    function parseURLParams() {
      const params = new URLSearchParams(window.location.search);
      const games = params.get('games')
        ? params.get('games').split(',').map(decodeURIComponent).filter(g => g && /^[a-zA-Z0-9\s\-_.,&]+$/.test(g))
        : [];
      const regions = params.get('regions')
        ? params.get('regions').split(',').map(decodeURIComponent).filter(r => r && /^[A-Z]{2}$/.test(r))
        : [];
      const sort = params.get('sort') || 'players';
      return { games, regions, sort };
    }

    function updateURL() {
      const selectedGames = getSelectedGames();
      const selectedRegions = getSelectedRegions();
      const params = new URLSearchParams();
      if (selectedGames.length > 0) params.set('games', selectedGames.map(encodeURIComponent).join(','));
      if (selectedRegions.length > 0) params.set('regions', selectedRegions.join(','));
      params.set('sort', currentSort);
      window.history.replaceState({}, document.title, `${window.location.pathname}?${params.toString()}`);
      urlParams = parseURLParams();
    }

    function startLoadingAnimation(message = '已连接，等待服务器数据') {
      let dots = 1;
      clearInterval(loadingInterval);
      clearInterval(reconnectCountdownIntervalId);
      reconnectCountdownIntervalId = null;
      statusDiv.textContent = message + '.';
      loadingInterval = setInterval(() => {
        dots = (dots % 3) + 1;
        statusDiv.textContent = `${message}${'.'.repeat(dots)}`;
      }, 500);
    }

    function stopLoadingAnimation(message) {
      clearInterval(loadingInterval);
      loadingInterval = null;
      if (!reconnectCountdownIntervalId) {
        statusDiv.textContent = message;
      }
    }

    function loadCachedData() {
      const cachedDataStr = sessionStorage.getItem('serverData');
      if (cachedDataStr) {
        try {
          const cachedData = JSON.parse(cachedDataStr);
          if (Array.isArray(cachedData)) {
            cachedData.forEach(server => {
              const key = `${server.ip}:${server.port}`;
              serverData.set(key, server);
            });
            updateFiltersFromData();
            applyUrlParamsToFilters();
            debouncedFilterAndRender();
            updateStatus();
          } else {
            sessionStorage.removeItem('serverData');
          }
        } catch (e) {
          console.error("Failed to parse cached data:", e);
          sessionStorage.removeItem('serverData');
        }
      }
      applyUrlParamsToFilters();
      debouncedFilterAndRender();
    }

    function addOrUpdateServer(server) {
      if (!server || typeof server.ip !== 'string' || typeof server.port !== 'number') {
        console.warn("Received invalid server data:", server);
        return false;
      }
      const gameDesc = server.game_description || '-';
      if (gameDesc === '-') return false;
      const key = `${server.ip}:${server.port}`;
      serverData.set(key, server);

      const regionDesc = server.country || 'unknown';
      let filtersChanged = false;
      if (!uniqueGames.has(gameDesc)) {
        uniqueGames.add(gameDesc);
        filtersChanged = true;
      }
      if (!uniqueRegions.has(regionDesc)) {
        uniqueRegions.add(regionDesc);
        filtersChanged = true;
      }
      if (filtersChanged) {
        updateFilterOptionsUI();
        applyUrlParamsToFilters();
      }
      return true;
    }

    function updateStatus() {
      const serverCount = serverData.size;
      const gameCount = uniqueGames.size;
      const regionCount = uniqueRegions.size;
      if (!reconnectCountdownIntervalId) {
        stopLoadingAnimation(`已加载 ${serverCount} 个服务器，${gameCount} 个游戏，${regionCount} 个地区。`);
      }
    }

    function connectWebSocket() {
      if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
        return;
      }
      clearTimeout(reconnectTimeoutId);
      reconnectTimeoutId = null;
      clearInterval(reconnectCountdownIntervalId);
      reconnectCountdownIntervalId = null;

      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${wsProtocol}//${window.location.host}/ws`;
      statusDiv.textContent = '正在连接服务器...';

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        reconnectDelay = 5000;
        clearInterval(reconnectCountdownIntervalId);
        reconnectCountdownIntervalId = null;
        startLoadingAnimation();
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'visitor_count') {
            visitorCountDiv.textContent = `${data.count} 位访客`;
          } else {
            const dataAdded = addOrUpdateServer(data);
            if (dataAdded) {
              debouncedFilterAndRender();
            }
          }
        } catch (e) {
          console.error("Error processing WebSocket message:", e, "Data:", event.data);
        }
      };
      
      const debouncedFullUpdate = debounce(() => {
        updateStatus();
        updateLastUpdateTime();
        sessionStorage.setItem('serverData', JSON.stringify(Array.from(serverData.values())));
      }, 500);
      
      ws.addEventListener('message', debouncedFullUpdate);


      ws.onerror = (error) => {
        console.error("WebSocket error:", error);
      };

      ws.onclose = (event) => {
        ws = null;
        if (event.code === 1000 || event.code === 1001) {
          stopLoadingAnimation('WebSocket 连接已关闭。');
          clearInterval(reconnectCountdownIntervalId);
          reconnectCountdownIntervalId = null;
          return;
        }
        clearInterval(loadingInterval);
        clearInterval(reconnectCountdownIntervalId);

        const reconnectAttemptTime = Date.now() + reconnectDelay;
        const updateCountdown = () => {
          const now = Date.now();
          const secondsRemaining = Math.ceil((reconnectAttemptTime - now) / 1000);
          if (secondsRemaining > 0) {
            statusDiv.textContent = `连接已断开，${secondsRemaining}秒后尝试重新连接...`;
          } else {
            statusDiv.textContent = '正在尝试重新连接...';
            clearInterval(reconnectCountdownIntervalId);
            reconnectCountdownIntervalId = null;
          }
        };
        updateCountdown();
        reconnectCountdownIntervalId = setInterval(updateCountdown, 1000);

        reconnectTimeoutId = setTimeout(connectWebSocket, reconnectDelay);
        reconnectDelay = Math.min(reconnectDelay * 2, maxReconnectDelay);
      };
    }

    function updateFiltersFromData() {
      uniqueGames.clear();
      uniqueRegions.clear();
      serverData.forEach(server => {
        uniqueGames.add(server.game_description || '-');
        uniqueRegions.add(server.country || 'unknown');
      });
      updateFilterOptionsUI();
    }

    function updateFilterOptionsUI() {
      const sortedGames = Array.from(uniqueGames).sort();
      const sortedRegions = Array.from(uniqueRegions).sort();
      initializeFilterOptions(gameFilterOptions, sortedGames, getSelectedGames());
      initializeFilterOptions(regionFilterOptions, sortedRegions, getSelectedRegions(), true);
      updateGameFilterButtonText();
      updateRegionFilterButtonText();
    }

    function applyUrlParamsToFilters() {
      let selectedGames = initialSelectedGames;
      let selectedRegions = initialSelectedRegions;

      if (serverData.size > 0) {
        selectedGames = selectedGames.filter(g => uniqueGames.has(g));
        selectedRegions = selectedRegions.filter(r => uniqueRegions.has(r));
      }

      applyCheckboxSelection(gameFilterOptions, selectedGames);
      applyCheckboxSelection(regionFilterOptions, selectedRegions);
      updateGameFilterButtonText();
      updateRegionFilterButtonText();
      currentSort = ['players', 'name', 'latency'].includes(urlParams.sort) ? urlParams.sort : 'players';
      sortBtn.textContent = {'players': '按人数排序', 'name': '按名称排序', 'latency': '按延迟排序'}[currentSort];
    }

    function applyCheckboxSelection(optionsContainer, selectedValues) {
      const checkboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb => { cb.checked = selectedValues.includes(cb.value); });
    }

    function initializeFilterOptions(optionsContainer, items, selectedItems, isRegion = false) {
      optionsContainer.innerHTML = '';
      items.forEach(item => {
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = item;
        checkbox.checked = selectedItems.includes(item);
        checkbox.addEventListener('change', () => {
          // BUG FIX: When filters change, immediately call the render function
          debouncedFilterAndRender();
          if (isRegion) updateRegionFilterButtonText();
          else updateGameFilterButtonText();
          updateURL();
        });
        label.appendChild(checkbox);
        if (isRegion && item !== 'unknown') {
          const flagImg = document.createElement('img');
          flagImg.src = `https://flagcdn.com/w40/${item.toLowerCase()}.png`;
          flagImg.alt = item;
          flagImg.className = 'flag-icon';
          flagImg.onerror = (e) => { e.target.style.display = 'none'; };
          label.appendChild(flagImg);
          label.appendChild(document.createTextNode(` ${item}`));
        } else {
          label.appendChild(document.createTextNode(item || '-'));
        }
        optionsContainer.appendChild(label);
      });
    }

    function getSelectedGames() {
      return Array.from(gameFilterOptions.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
    }

    function getSelectedRegions() {
      return Array.from(regionFilterOptions.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
    }

    function updateGameFilterButtonText() {
      const selectedGames = getSelectedGames();
      const count = selectedGames.length;
      if (count === 0) { gameFilterBtn.textContent = '选择游戏'; gameFilterBtn.title = ''; }
      else if (count === uniqueGames.size && serverData.size > 0) { gameFilterBtn.textContent = '所有游戏'; gameFilterBtn.title = '所有游戏'; }
      else { const joined = selectedGames.join(', '); gameFilterBtn.textContent = joined.substring(0, 15) + (joined.length > 15 ? '...' : ''); gameFilterBtn.title = joined; }
    }

    function updateRegionFilterButtonText() {
      const selectedRegions = getSelectedRegions();
      const count = selectedRegions.length;
      if (count === 0) { regionFilterBtn.textContent = '选择地区'; regionFilterBtn.title = ''; }
      else if (count === uniqueRegions.size && serverData.size > 0) { regionFilterBtn.textContent = '所有地区'; regionFilterBtn.title = '所有地区'; }
      else { const joined = selectedRegions.join(', '); regionFilterBtn.textContent = joined.substring(0, 15) + (joined.length > 15 ? '...' : ''); regionFilterBtn.title = joined; }
    }

    function toggleGameMultiselect() { gameFilter.classList.toggle('open'); regionFilter.classList.remove('open'); sortDropdown.classList.remove('open'); }
    function toggleRegionMultiselect() { regionFilter.classList.toggle('open'); gameFilter.classList.remove('open'); sortDropdown.classList.remove('open'); }
    function toggleDropdown() { sortDropdown.classList.toggle('open'); gameFilter.classList.remove('open'); regionFilter.classList.remove('open'); }

    function selectSort(method) {
      currentSort = ['players', 'name', 'latency'].includes(method) ? method : 'players';
      sortBtn.textContent = {'players': '按人数排序', 'name': '按名称排序', 'latency': '按延迟排序'}[currentSort];
      sortDropdown.classList.remove('open');
      debouncedFilterAndRender();
      updateURL();
    }

    function showTooltip(cell, name, event) {
      if (currentTooltip) {
        currentTooltip.remove();
        currentTooltip = null;
      }

      const tooltip = document.createElement('div');
      tooltip.className = 'tooltip';
      tooltip.textContent = name || '-';
      document.body.appendChild(tooltip);

      // 修复: 计算位置时考虑页面滚动偏移
      const rect = cell.getBoundingClientRect();
      const scrollX = window.scrollX || window.pageXOffset;
      const scrollY = window.scrollY || window.pageYOffset;
      
      const isMobile = window.matchMedia('(max-width: 680px)').matches;
      let x, y;

      if (isMobile && event.type === 'touchstart') {
        x = event.touches[0].clientX + scrollX;
        y = event.touches[0].clientY + scrollY + 10;
      } else {
        x = event.clientX + scrollX + 10;
        y = event.clientY + scrollY + 10;
      }

      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;

      // 调整位置避免超出视口
      const tooltipRect = tooltip.getBoundingClientRect();
      const viewportRight = scrollX + window.innerWidth;
      const viewportBottom = scrollY + window.innerHeight;
      const tooltipRight = x + tooltipRect.width;
      const tooltipBottom = y + tooltipRect.height;

      if (tooltipRight > viewportRight) {
        x = viewportRight - tooltipRect.width - 10;
      }
      if (tooltipBottom > viewportBottom) {
        y = viewportBottom - tooltipRect.height - 10;
      }

      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;

      setTimeout(() => tooltip.classList.add('visible'), 10);
      currentTooltip = tooltip;
    }

    function hideTooltip() {
      if (currentTooltip) {
        currentTooltip.remove();
        currentTooltip = null;
      }
    }

    function showSupportModal() {
      const modal = document.getElementById('supportModal');
      modal.classList.add('show');
    }

    function hideSupportModal() {
      const modal = document.getElementById('supportModal');
      modal.classList.remove('show');
    }

    // 新增：显示服务器历史数据模态框
    function showHistoryModal(server) {
      const key = `${server.ip}:${server.port}`;
      historyServerName.textContent = server.name || '未知服务器';
      historyServerInfo.textContent = `${server.ip}:${server.port}`;
      
      // 显示加载中状态
      historyTableBody.innerHTML = '<tr><td colspan="2" style="text-align: center;">加载中...</td></tr>';
      historyNoData.style.display = 'none';
      historyTableContainer.style.display = 'table';
      
      // 销毁之前的图表实例
      if (historyChartInstance) {
        historyChartInstance.destroy();
        historyChartInstance = null;
      }
      
      // 显示模态框
      historyModal.classList.add('show');
      
      // 获取服务器历史数据
      axios.get(`/api/server-history/${encodeURIComponent(key)}`)
        .then(response => {
          const historyData = response.data;
          renderHistoryData(historyData);
        })
        .catch(error => {
          console.error('获取服务器历史数据失败:', error);
          historyTableBody.innerHTML = '<tr><td colspan="2" style="text-align: center; color: var(--muted);">获取历史数据失败</td></tr>';
          historyNoData.style.display = 'block';
          historyTableContainer.style.display = 'none';
        });
    }

    // 新增：隐藏服务器历史数据模态框
    function hideHistoryModal() {
      historyModal.classList.remove('show');
    }

    // 新增：渲染服务器历史数据
    function renderHistoryData(historyData) {
      if (!historyData.history || Object.keys(historyData.history).length === 0) {
        historyNoData.style.display = 'block';
        historyTableContainer.style.display = 'none';
        return;
      }
      
      historyNoData.style.display = 'none';
      historyTableContainer.style.display = 'table';
      
      // 准备图表数据
      const dates = Object.keys(historyData.history).sort();
      const playerCounts = dates.map(date => historyData.history[date]);
      
      // 渲染表格
      historyTableBody.innerHTML = '';
      dates.forEach(date => {
        const row = document.createElement('tr');
        const dateCell = document.createElement('td');
        const countCell = document.createElement('td');
        
        dateCell.textContent = formatDate(date);
        countCell.textContent = historyData.history[date];
        
        row.appendChild(dateCell);
        row.appendChild(countCell);
        historyTableBody.appendChild(row);
      });
      
      // 渲染图表
      renderHistoryChart(dates, playerCounts);
    }

    // 新增：格式化日期
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString('zh-CN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
      });
    }

    // 新增：渲染历史数据图表
    function renderHistoryChart(dates, playerCounts) {
      const ctx = historyChart.getContext('2d');
      
      // 销毁之前的图表实例
      if (historyChartInstance) {
        historyChartInstance.destroy();
      }
      
      historyChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: dates.map(formatDate),
          datasets: [{
            label: '最大在线人数',
            data: playerCounts,
            borderColor: 'rgba(110, 231, 183, 0.8)',
            backgroundColor: 'rgba(110, 231, 183, 0.1)',
            tension: 0.3,
            fill: true,
            pointBackgroundColor: 'rgba(110, 231, 183, 1)',
            pointBorderColor: '#fff',
            pointBorderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              labels: {
                color: 'rgba(215, 225, 234, 0.8)'
              }
            },
            tooltip: {
              backgroundColor: 'rgba(14, 16, 18, 0.9)',
              titleColor: 'rgba(215, 225, 234, 0.9)',
              bodyColor: 'rgba(215, 225, 234, 0.8)',
              borderColor: 'rgba(255, 255, 255, 0.1)',
              borderWidth: 1,
              displayColors: false
            }
          },
          scales: {
            x: {
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              },
              ticks: {
                color: 'rgba(215, 225, 234, 0.7)'
              }
            },
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              },
              ticks: {
                color: 'rgba(215, 225, 234, 0.7)'
              }
            }
          }
        }
      });
    }

    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
      };
    }

    const debouncedFilterAndRender = debounce(() => {
        filterAndRenderTable();
    }, 50);

    function filterAndRenderTable() {
      if (isRendering) return; // Prevent re-entry if already rendering

      const selectedGames = getSelectedGames();
      const selectedRegions = getSelectedRegions();
      let serversToRender = Array.from(serverData.values()).filter(server =>
        (selectedGames.length === 0 || selectedGames.includes(server.game_description || '-')) &&
        (selectedRegions.length === 0 || selectedRegions.includes(server.country || 'unknown'))
      );
      sortServers(serversToRender);

      // 修复：在渲染前锁定表格容器高度
      if (tableContainer) {
        const currentHeight = tableContainer.scrollHeight;
        tableContainer.style.setProperty('--table-container-height', `${currentHeight}px`);
        tableContainer.classList.add('lock-height');
      }

      // BUG FIX: The key now includes the ORDER of servers by mapping their unique keys.
      // This ensures that a change in sorting (which changes the order) will trigger a re-render.
      const serversKey = JSON.stringify(serversToRender.map(s => s.ip + ':' + s.port));
      if (serversKey === lastRenderedKey) {
        // 修复：如果内容没有变化，也需要移除高度锁定
        if (tableContainer) {
          setTimeout(() => {
            tableContainer.classList.remove('lock-height');
          }, 10);
        }
        return; // Nothing changed, no need to re-render.
      }
      lastRenderedKey = serversKey;
      
      isRendering = true;
      requestAnimationFrame(() => {
        renderTable(serversToRender);
        isRendering = false;
      });
    }

    function sortServers(servers) {
      servers.sort((a, b) => {
        if (currentSort === 'players') {
          const diff = (b.current_players ?? -1) - (a.current_players ?? -1);
          if (diff) return diff;
          return (a.name || '').localeCompare(b.name || '');
        } else if (currentSort === 'name') {
          return (a.name || '').localeCompare(b.name || '');
        } else {
          const latA = a.latency ?? Infinity;
          const latB = b.latency ?? Infinity;
          const diff = latA - latB;
          if (diff) return diff;
          return (b.current_players ?? -1) - (a.current_players ?? -1);
        }
      });
    }

    // --- ANIMATION MAGIC: Heavily refactored renderTable with FLIP ---
    function renderTable(servers) {
      const oldPositions = new Map();
      const existingRows = new Map();

      // 1. FIRST: Record the initial position of all existing rows.
      tbody.querySelectorAll('[data-key]').forEach(row => {
          oldPositions.set(row.dataset.key, row.getBoundingClientRect());
          existingRows.set(row.dataset.key, row);
      });
      
      const fragment = document.createDocumentFragment();
      const updatedKeys = new Set();
      const newRowsToAnimate = [];

      // Build the new table body in a fragment for performance
      servers.forEach(server => {
          const key = `${server.ip}:${server.port}`;
          updatedKeys.add(key);
          const ipPort = `${server.ip}:${server.port}`;
          const isZeroPlayers = server.current_players === 0;
          let row = existingRows.get(key);

          if (row) {
              // Update existing row's content
              updateCellContent(row.cells[1], server.game_description || '-');
              updateCellContent(row.cells[2], server.name || '-');
              row.cells[3].querySelector('.ip-link').textContent = ipPort;
              updateCellContent(row.cells[4], server.isp || '-');
              updateCellContent(row.cells[5], server.os || '-');
              updateCellContent(row.cells[6], `${server.current_players ?? '?'}/${server.max_players ?? '?'}`);
              updateCellContent(row.cells[7], server.map || '-');
              updateCellContent(row.cells[8], server.version || '-');
              queueLatencyUpdate(row.cells[9], server.latency ?? '-', key);
              row.classList.toggle('zero-players', isZeroPlayers);
          } else {
              // Create a new row
              row = createRow(server);
              newRowsToAnimate.push(row);
          }
          fragment.appendChild(row);
      });
      
      // Handle rows that need to be removed
      existingRows.forEach((row, key) => {
          if (!updatedKeys.has(key)) {
              row.classList.add('removing');
              setTimeout(() => row.remove(), 300);
          }
      });
      
      // 2. LAST: Apply the changes to the DOM in one go.
      tbody.innerHTML = '';
      tbody.appendChild(fragment);

      // Animate new rows
      newRowsToAnimate.forEach(row => row.classList.add('new-row'));

      // 3. INVERT & PLAY: Animate the rows that moved.
      const rowsToMove = [];
      tbody.querySelectorAll('[data-key]').forEach(row => {
          const oldPos = oldPositions.get(row.dataset.key);
          if (!oldPos || newRowsToAnimate.includes(row)) return;

          const newPos = row.getBoundingClientRect();
          const dx = oldPos.left - newPos.left;
          const dy = oldPos.top - newPos.top;

          if (dx !== 0 || dy !== 0) {
              row.style.transform = `translate(${dx}px, ${dy}px)`;
              rowsToMove.push(row);
          }
      });
      
      // This forces the browser to apply the transform before starting the transition.
      requestAnimationFrame(() => {
          rowsToMove.forEach(row => {
              row.classList.add('moving');
              row.style.transform = ''; // Animate back to its natural position
          });
          // Clean up the animation class after it's finished.
          rowsToMove.forEach(row => {
              row.addEventListener('transitionend', () => {
                  row.classList.remove('moving');
              }, { once: true });
          });
      });

      processLatencyUpdates();

      // 修复：在动画结束后移除高度锁定
      if (tableContainer) {
        // 清除之前的定时器
        if (scrollHideTimer) {
          clearTimeout(scrollHideTimer);
        }
        // 设置定时器在动画结束后移除高度锁定
        scrollHideTimer = setTimeout(() => {
          tableContainer.classList.remove('lock-height');
          scrollHideTimer = null;
        }, 500); // 调整为匹配FLIP动画时间（0.5s），更平滑
      }
    }
    
    function createRow(server) {
        const row = document.createElement('tr');
        const key = `${server.ip}:${server.port}`;
        row.dataset.key = key;
        row.classList.toggle('zero-players', server.current_players === 0);

        const countryCode = (server.country || 'unknown').toLowerCase();
        const ipPort = `${server.ip}:${server.port}`;

        const cellCountry = row.insertCell();
        cellCountry.className = 'country';
        if (countryCode !== 'unknown') {
            const flagImg = document.createElement('img');
            flagImg.src = `https://flagcdn.com/w40/${countryCode}.png`;
            flagImg.alt = server.country || '';
            flagImg.className = 'flag-icon';
            flagImg.onerror = e => { e.target.style.display = 'none'; cellCountry.textContent = countryCode.toUpperCase(); };
            cellCountry.appendChild(flagImg);
        } else {
            cellCountry.textContent = '?';
        }

        createCell(row, 'game', server.game_description || '-');
        const cellName = createCell(row, 'name', server.name || '-');
        cellName.addEventListener('mouseenter', e => showTooltip(cellName, server.name, e));
        cellName.addEventListener('mouseleave', hideTooltip);
        // 修改：点击服务器名称时显示历史数据
        cellName.addEventListener('click', () => showHistoryModal(server));
        cellName.addEventListener('touchstart', e => { e.preventDefault(); showHistoryModal(server); });
        
        const cellIp = createCell(row, 'ip');
        const link = document.createElement('a');
        link.href = `steam://connect/${ipPort}`;
        link.className = 'ip-link';
        link.textContent = ipPort;
        cellIp.appendChild(link);

        createCell(row, 'isp', server.isp || '-');
        createCell(row, 'os', server.os || '-');
        createCell(row, 'players', `${server.current_players ?? '?'}/${server.max_players ?? '?'}`);
        createCell(row, 'map', server.map || '-');
        createCell(row, 'version', server.version || '-');
        createCell(row, 'latency', server.latency ?? '-');

        return row;
    }


    function updateCellContent(cell, newContent) {
      const str = String(newContent);
      if (cell.textContent !== str) {
        cell.textContent = str; // textContent 已安全，转义HTML
      }
    }

    function queueLatencyUpdate(cell, newLatency, key) {
      const currentLatency = cell.textContent;
      const newStr = String(newLatency);
      if (currentLatency !== newStr) {
          latencyUpdateQueue.set(key, { cell, newLatency: newStr });
      }
    }

    const processLatencyUpdates = debounce(() => {
      latencyUpdateQueue.forEach(({ cell, newLatency }) => {
        if (cell.textContent !== newLatency) {
          cell.textContent = newLatency;
          cell.classList.add('updated');
          setTimeout(() => cell.classList.remove('updated'), 600);
        }
      });
      latencyUpdateQueue.clear();
    }, 200); // 微调debounce时间为200ms，提升响应

    function createCell(row, className, text = '') {
      const cell = row.insertCell();
      cell.className = className;
      cell.textContent = text;
      return cell;
    }

    function updateLastUpdateTime() {
      lastUpdateTime = Date.now();
      lastUpdatedDiv.classList.remove('hidden');
      updateTimeSpan.textContent = '0';
    }

    function startUpdateTimer() {
      clearInterval(updateTimerInterval);
      updateTimerInterval = setInterval(() => {
        if (lastUpdateTime) {
          const sec = Math.floor((Date.now() - lastUpdateTime) / 1000);
          updateTimeSpan.textContent = sec;
        }
      }, 1000);
    }

    async function refreshServers() {
      const btn = document.querySelector('.refresh-btn');
      btn.disabled = true;
      const orig = statusDiv.textContent;
      if (!reconnectCountdownIntervalId) startLoadingAnimation('正在请求刷新...');

      try {
        await axios.get('/api/servers');
        setTimeout(() => {
          btn.disabled = false;
          if (!reconnectCountdownIntervalId && statusDiv.textContent.startsWith('正在请求刷新')) {
            statusDiv.textContent = orig;
          }
        }, 3000);
      } catch (e) {
        console.error("Error requesting server refresh:", e);
        if (!reconnectCountdownIntervalId) stopLoadingAnimation('刷新请求失败');
        btn.disabled = false;
      }
    }

    window.onload = () => {
      urlParams = parseURLParams();
      loadCachedData();
      startUpdateTimer();
      connectWebSocket();

      document.addEventListener('click', (e) => {
        if (currentTooltip && !e.target.closest('.name')) {
          hideTooltip();
        }
        const modal = document.getElementById('supportModal');
        if (modal.classList.contains('show') && e.target === modal) {
          hideSupportModal();
        }
        
        const historyModal = document.getElementById('historyModal');
        if (historyModal.classList.contains('show') && e.target === historyModal) {
          hideHistoryModal();
        }
        
        if (!gameFilter.contains(e.target)) gameFilter.classList.remove('open');
        if (!regionFilter.contains(e.target)) regionFilter.classList.remove('open');
        if (!sortDropdown.contains(e.target)) sortDropdown.classList.remove('open');
      });
    };
  </script>
</body>
</html>